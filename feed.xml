<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blank Page Tech</title>
  <subtitle>Lets build things</subtitle>
  <id>http://willschenk.com/</id>
  <link href="http://willschenk.com/"/>
  <link href="http://willschenk.com/feed.xml" rel="self"/>
  <updated>2015-02-21T16:46:19-05:00</updated>
  <author>
    <name>Will Schenk</name>
  </author>
  <entry>
    <title>Why Engineers build crappy products</title>
    <link rel="alternate" href="http://willschenk.com/why-engineers-build-crappy-products/"/>
    <id>http://willschenk.com/why-engineers-build-crappy-products/</id>
    <published>2015-02-20T19:00:00-05:00</published>
    <updated>2015-02-20T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;There&amp;#39;s a certain user interface that, when you first see it, screams out of you that it was designed by an engineer. &lt;/p&gt;

&lt;p&gt;&lt;img alt="designed by an engineer" src="http://www.pspad.com/img/screen/mainfull.png" /&gt;&lt;/p&gt;

&lt;p&gt;(&lt;em&gt;via &lt;a href="http://daringfireball.net"&gt;Daring Fireball&lt;/a&gt; &lt;a href="https://www.google.com/search?client=safari&amp;amp;rls=en&amp;amp;q=daring+fireball+user+interface+of+the+week&amp;amp;ie=UTF-8&amp;amp;oe=UTF-8"&gt;User Interface of the Week&lt;/a&gt;&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Why does that happen? What is it in the nature of engineering or software development process that leads to user interfaces that are impossible for the users to actually use?&lt;/p&gt;

&lt;h2 id="perfect-storm-of-user-discontent"&gt;Perfect Storm of User Discontent&lt;/h2&gt;

&lt;p&gt;The short version:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The most interesting part of engineer&amp;#39;s jobs is the obsession with the possibilities in the solution space - all the cool shit you can make completed do.&lt;/li&gt;
&lt;li&gt;Engineers don&amp;#39;t want to make choices that limit power and flexibly.&lt;/li&gt;
&lt;li&gt;Engineers value adding potential functionality higher than removing unneeded complexity.&lt;/li&gt;
&lt;li&gt;Engineers want to engineer their way out of design problems.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="being-a-people-person"&gt;Being a people person&lt;/h2&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/RAY27NU1Jog" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;The process of thinking about a new product begins with an attempt to understand what it is that the software supposed to do, that is, it starts with specifying a solution to a problem. This is assuming that the problem itself is correctly framed, which it often isn&amp;#39;t.  These specifications generally take form in things like user stories and wireframes which are ways of specifying both what the user is trying to do and the specific interface that the user will use to achieve those goals.&lt;/p&gt;

&lt;p&gt;Implicit in this is the understanding of what technology is able to do. Sometimes, especially for a product with a novel technical solution, what technology is able to do it isn&amp;#39;t completely understood. And regardless of whether or not the solution is in a known problem space, there will always be different challenges that will come up when building something.  Building software is actually very difficult.&lt;/p&gt;

&lt;p&gt;Given that fact, engineering will look at design, start thinking about what the general shape of the solution looks like, and should structure their development efforts around the parts of the product that seem the most risky -- the parts that will be technically the most challenging. If we can prove that those parts will work, with a prototype or make it functional with a sort of mock interface, then and only then does it make sense to flush out the rest of the product.&lt;/p&gt;

&lt;h2 id="the-fractal-nature-of-engineering"&gt;The fractal nature of engineering&lt;/h2&gt;

&lt;p&gt;This is the fun part. Every engineer loves greenfield development because it allows them to explore the terrain without having to deal with the trade-offs, constraints, and messiness of existing code. The process is one of exploration, of being able to explore a technical space of possibilities and potentialities. This is really awesome, and a large part of what makes engineering interesting.&lt;/p&gt;

&lt;p&gt;The experience is of building little things, putting them together in novel ways, and build things which are increasingly powerful.  This leads engineers to put knobs and buttons and gizmos on different functionality to make it easier to explore all of what it can do.  Its socially rewarding to show off all this cool stuff, not just what it does not, but also what it&amp;#39;s capable of doing.  Focusing on the technology aspect of it, leads people to optimize the functionality in both breath and power.&lt;/p&gt;

&lt;h2 id="interface-ecstasy"&gt;Interface ecstasy&lt;/h2&gt;

&lt;p&gt;&lt;img src="images/product/nosql_query-89043e77.png" /&gt;
&lt;em&gt;Engineers Keeping it Real: Go Fuck Yourself&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The problem is products aren&amp;#39;t about technology. Technology is necessary but not sufficient to build products. Technology is just the plumbing, the thing which makes it possible, but not actually the thing that people care about.&lt;/p&gt;

&lt;p&gt;The ecstasy of possibility is in conflict with producing elegant products, because products are fundamentally about making choices and creating clarity around something which is very complicated. This is more than missing the forest for the trees; the ideals and aspirations of both efforts are directly contradictory.&lt;/p&gt;

&lt;h2 id="example-me-doing-yet-another-dumb-thing"&gt;Example: Me doing Yet Another Dumb Thing&lt;/h2&gt;

&lt;p&gt;We were recently &lt;a href="http://shoutouts.happyfuncorp.com/"&gt;building a product&lt;/a&gt; that would use email as an interface touch point.  Specifications, being what they are, didn&amp;#39;t really explain what should happen when a user attempted to interact with another user who had only partially setup their account.  We were just playing around with some stuff, so it&amp;#39;s not even fair to blame the specifications on being vague; as it often goes when building something, we ended up way deeper in the weeds than anyone intended.&lt;/p&gt;

&lt;p&gt;Looking at this from the edge case perspective, that is, while focusing on the engineering implementation and building in robustness of response based upon stuff that could happen, my instinct was to start building out code that would deal with this.  It also uses slack as an endpoint, and in that set of scenarios it does something clever, so naturally email should do something clever as well.&lt;/p&gt;

&lt;p&gt;I started down the path of being able to store partial requests that would get queued up and in the user interface to resolve in the future.  I started going down the path of creating a whole bunch of functionality because I was thinking about things in terms of the technology, the other interfaces had something &amp;quot;elegant&amp;quot;, and I wanted to build something complete.  Madness was creeping into the interface.&lt;/p&gt;

&lt;p&gt;This is not something that&amp;#39;s core to the product.  No one actually cares. In the situation like this, the answer really isn&amp;#39;t to be a lot of technology solution. I thought that there isn&amp;#39;t a problem, but that a technology solution is not the most effective way to solve the problem.  It&amp;#39;s actually a design problem.&lt;/p&gt;

&lt;h2 id="technology-is-the-easy-part"&gt;Technology is the easy part&lt;/h2&gt;

&lt;p&gt;If the teams aren&amp;#39;t integrated, that is to say if the design team &amp;quot;finishes&amp;quot; their work and then lobs it over the fence to the engineering team, this conversation will take the form of engineering requesting designs for something that &amp;quot;was missed and we need to solve&amp;quot;. The solution, in this case, is not to &amp;quot;solve it&amp;quot; at all, but to reframe the problem.  And this reframing puts it into a place that engineers don&amp;#39;t like to be.  It was not to build out a whole partially completed the request queuing system that the user could resolve, be alerts of outstanding tasks or whatever, it was instead to simply keep the email interface simple and redirect them to the main flow on the website.&lt;/p&gt;

&lt;p&gt;In short, the reason why engineers tend to be crappy product designers is that &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The most interesting part of engineer&amp;#39;s jobs is the obsession with the possibilities in the solution space - all the cool shit you can make completed do.&lt;/li&gt;
&lt;li&gt;Engineers don&amp;#39;t want to make choices that limit power and flexibly.&lt;/li&gt;
&lt;li&gt;Engineers value adding potential functionality higher than removing unneeded complexity.&lt;/li&gt;
&lt;li&gt;Engineers want to engineer their way out of design problems.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Setting up Rails testing with rspec, devise, and the gang</title>
    <link rel="alternate" href="http://willschenk.com/setting-up-testing/"/>
    <id>http://willschenk.com/setting-up-testing/</id>
    <published>2015-01-22T19:00:00-05:00</published>
    <updated>2015-01-22T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;The goal is to get features out fast, and interate on them quickly.  Does anyone care about it?  What do they care about?  How do we make it better?&lt;/p&gt;

&lt;p&gt;As projects get bigger, both in terms of people using the site as well as people &lt;em&gt;working&lt;/em&gt; on the site, testing and quality become relatively more important.  Adding tests introduces drag, and the theory is that you invest now for payoffs later.  What&amp;#39;s the least amount of drag we can add to the process to get us in a good place for when it will start to pay off?&lt;/p&gt;

&lt;p&gt;RSpec feature specs lets developers create testing click paths through the application, looking at the flow though the app.  It doesn&amp;#39;t focus enough on the design details, and going through a test driving development process with this way will end up with sites &amp;#39;working&amp;#39; using only an engineer&amp;#39;s defination, so as a MVP implementor you&amp;#39;ll need to find a way to resist the temptation, no matter how nifty the backend flow state is.&lt;/p&gt;

&lt;p&gt;This article will go through how the testing environment is set up on &lt;a href="http://seed.happyfuncorp.com"&gt;HappySeed&lt;/a&gt; where we focus mainly on RSpec feature specs.  Seed does this all automatically, but its nice to have it written down in a one place so we all know what&amp;#39;s going on.  Let&amp;#39;s get into it.&lt;/p&gt;

&lt;h2 id="install-rspec-factorygirl-capybara-and-guard"&gt;Install RSpec, FactoryGirl, Capybara, and Guard&lt;/h2&gt;

&lt;p&gt;Lets fire up a new rails app, and pass the &lt;code&gt;-T&lt;/code&gt; option to not include TestUnit.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails new test_app -T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now add some gems to the &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;group :development, :test do
  gem &amp;#39;rspec-rails&amp;#39;
  gem &amp;#39;factory_girl_rails&amp;#39;
  gem &amp;#39;capybara&amp;#39;
  gem &amp;#39;guard-rspec&amp;#39;
  gem &amp;#39;spring-commands-rspec&amp;#39;
  gem &amp;#39;vcr&amp;#39;
end

group :test do
  gem &amp;#39;webmock&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets go through this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://rspec.info"&gt;&lt;code&gt;rpsec&lt;/code&gt;&lt;/a&gt; (implied as a dependancy) is the testing framework that we are going to use&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/thoughtbot/factory_girl"&gt;&lt;code&gt;factory_girl&lt;/code&gt;&lt;/a&gt; (implied) lets us code smart database fixtures in ruby, in things called &lt;em&gt;factories&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jnicklas/capybara"&gt;&lt;code&gt;capybara&lt;/code&gt;&lt;/a&gt; lets helps you test web applications by simulating how a real user would interact with your app. &lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/guard/guard"&gt;&lt;code&gt;guard&lt;/code&gt;&lt;/a&gt; (implied) makes rerunning tests a snap, by watching the filesystem for when you save files and triggering events automatically&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/bblimke/webmock"&gt;&lt;code&gt;webmock&lt;/code&gt;&lt;/a&gt; locks down your test environment from talking to the internet&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/vcr/vcr"&gt;&lt;code&gt;vcr&lt;/code&gt;&lt;/a&gt; record your test suite&amp;#39;s HTTP interactions and replay them during future test runs for fast, deterministic, accurate tests&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rspec/rspec-rails"&gt;&lt;code&gt;rspec-rails&lt;/code&gt;&lt;/a&gt; is the rails integration with rspec, which depends upon rspec itself.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/thoughtbot/factory_girl_rails"&gt;&lt;code&gt;factory_girl_rails&lt;/code&gt;&lt;/a&gt; is the rails integration with factory_girl.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/guard/guard-rspec"&gt;&lt;code&gt;guard-rspec&lt;/code&gt;&lt;/a&gt; is rspec integration with guard&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jonleighton/spring-commands-rspec"&gt;&lt;code&gt;spring-commands-rspec&lt;/code&gt;&lt;/a&gt; lets you integrate rspec with spring, which means that your tests will run much faster.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you are interested in using cucumber, see below for steps to integrate it.&lt;/p&gt;

&lt;h2 id="base-configuration-of-rspec-and-guard"&gt;Base configuration of rspec and guard&lt;/h2&gt;

&lt;p&gt;Lets make sure that spring knows about rspec:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle install
$ spring binstub --all
* bin/rake: spring already present
* bin/rspec: generated with spring
* bin/rails: spring already present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a &lt;code&gt;bin/rspec&lt;/code&gt; command that lets us run our tests.  Lets create a Guardfile and then tell guard to use this command:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ guard init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then edit the newly generated &lt;code&gt;Guardfile&lt;/code&gt; to use the spring version of the rspec runner.  I also like to run all of the tests when I start up guard, because the more the merrier.  In &lt;code&gt;Guardfile&lt;/code&gt;, change the &lt;code&gt;guard :rspec&lt;/code&gt; line to:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;guard :rspec, cmd: &amp;quot;bin/rspec&amp;quot;, all_on_start: true do
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we install the rspec files:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails g rspec:install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates 3 files:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;create  .rspec
create  spec
create  spec/spec_helper.rb
create  spec/rails_helper.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I like to have the output in documentation format by default, so we can edit the &lt;code&gt;.rspec&lt;/code&gt; file to be:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;--color
--require spec_helper
--format documentation
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="add-login-support-and-factory-girl-to-spec_helper"&gt;Add login support and factory girl to spec_helper&lt;/h2&gt;

&lt;p&gt;Getting feature and controller specs to work with authentication is a bit tricky.  We&amp;#39;re going to assume that you use &lt;a href="/setting-up-devise-with-twitter-and-facebook-and-other-omniauth-schemes-without-email-addresses/"&gt;devise for authentication&lt;/a&gt;, but this should support anything that uses &lt;a href="https://github.com/hassox/warden"&gt;warden&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;Add devise to &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;#39;devise&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create &lt;code&gt;spec/support/controller_helpers.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module ControllerHelpers
  def login_with(user = double(&amp;#39;user&amp;#39;), scope = :user)
    current_user = &amp;quot;current_#{scope}&amp;quot;.to_sym
    if user.nil?
      allow(request.env[&amp;#39;warden&amp;#39;]).to receive(:authenticate!).and_throw(:warden, {:scope =&amp;gt; scope})
      allow(controller).to receive(current_user).and_return(nil)
    else
      allow(request.env[&amp;#39;warden&amp;#39;]).to receive(:authenticate!).and_return(user)
      allow(controller).to receive(current_user).and_return(user)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the top of &lt;code&gt;spec_helper.rb&lt;/code&gt; add:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require_relative &amp;#39;support/controller_helpers&amp;#39;
require &amp;#39;devise&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the config block add:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  config.include ControllerHelpers, type: :controller
  Warden.test_mode!

  config.after do
    Warden.test_reset!
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then edit &lt;code&gt;rails_helper.rb&lt;/code&gt; and put the following in the config block:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  config.include FactoryGirl::Syntax::Methods
  config.include Devise::TestHelpers, type: :controller
  config.include Warden::Test::Helpers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;If you are getting uncaught throw :warden errors then make sure you have the right includes in the right config files!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This gives you a few things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FactoryGirl&lt;/code&gt; syntax methods, which let you use things like &lt;code&gt;create( :user )&lt;/code&gt; in your tests, which uses &lt;code&gt;FactoryGirl&lt;/code&gt; to generate a database object.&lt;/li&gt;
&lt;li&gt;helper methods to &lt;code&gt;sign_in&lt;/code&gt; a user for a specific scope.  This could be used as &lt;code&gt;sign_in create( :user )&lt;/code&gt; at the beginning of your controller test methods, and &lt;code&gt;sign_in nil&lt;/code&gt; to simulate an anonymous user.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="example-controller-spec"&gt;Example controller spec&lt;/h2&gt;

&lt;p&gt;This example assumes that you&amp;#39;ve already setup devise.  If not, you can get something up and running doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rails g devise:install &amp;amp;&amp;amp; rails g devise User &amp;amp;&amp;amp; rake db:migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(I go into slightly more detail in setting up &lt;a href="/setting-up-devise-with-twitter-and-facebook-and-other-omniauth-schemes-without-email-addresses/"&gt;devise for authentication&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Assuming that you&amp;#39;ve already setup devise, lets look at how to implement a controller spec.  First lets create a simple scaffold for a post:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails g scaffold post name:string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And lets make it require authentication in &lt;code&gt;posts_controller.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class PostsController &amp;lt; ApplicationController
  before_action :authenticate_user!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And replace &lt;code&gt;posts_controller_spec.rb&lt;/code&gt; with:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;rails_helper&amp;#39;

RSpec.describe PostsController, :type =&amp;gt; :controller do
  describe &amp;quot;anonymous user&amp;quot; do
    before :each do
      # This simulates an anonymous user
      login_with nil
    end

    it &amp;quot;should be redirected to signin&amp;quot; do
      get :index
      expect( response ).to redirect_to( new_user_session_path )
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run &lt;code&gt;guard&lt;/code&gt;, a few of the scaffold generate things will fail, since we are now forcing signin to check out this page.  Our spec will correctly redirect the user to sign in.&lt;/p&gt;

&lt;p&gt;Lets now simulate a logged in user:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  it &amp;quot;should let a user see all the posts&amp;quot; do
    login_with create( :user )
    get :index
    expect( response ).to render_template( :index )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Guard should try and run this tests but fail because we can&amp;#39;t configured a user factory.&lt;/p&gt;

&lt;p&gt;Lets set that up now in &lt;code&gt;spec/factories/user.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;FactoryGirl.define do
  sequence :email do |n|
    &amp;quot;person#{n}@example.com&amp;quot;
  end
end

FactoryGirl.define do
  factory :user, :class =&amp;gt; &amp;#39;User&amp;#39; do
    email
    password &amp;#39;12345678&amp;#39;
    password_confirmation &amp;#39;12345678&amp;#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going back to the guard window, press &lt;em&gt;return&lt;/em&gt; to run everything again and verify.  (Guard doens&amp;#39;t know that the &lt;code&gt;posts_controller_spec.rb&lt;/code&gt; depends upon the user factory changing.)&lt;/p&gt;

&lt;h2 id="example-rspec-feature"&gt;Example rspec feature&lt;/h2&gt;

&lt;p&gt;Feature specs are more interesting, since they let you walk through the site and how it works.  Lets build one now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails g rspec:feature add_new_post
      create  spec/features/add_new_posts_spec.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And lets add something there now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;rails_helper&amp;#39;

feature &amp;quot;AddNewPosts&amp;quot;, :type =&amp;gt; :feature do
  it &amp;quot;should require the user log in before adding a post&amp;quot; do
    password = &amp;quot;123456789&amp;quot;
    u = create( :user, password: password, password_confirmation: password )

    visit new_post_path

    within &amp;quot;#new_user&amp;quot; do
      fill_in &amp;quot;user_email&amp;quot;, with: u.email
      fill_in &amp;quot;user_password&amp;quot;, with: password
    end

    click_button &amp;quot;Log in&amp;quot;

    within &amp;quot;#new_post&amp;quot; do
      fill_in &amp;quot;post_name&amp;quot;, with: &amp;quot;Post title&amp;quot;
    end

    click_link_or_button &amp;quot;Create Post&amp;quot;

    expect( Post.count ).to eq(1)
    expect( Post.first.name).to eq( &amp;quot;Post title&amp;quot;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This first creates a new user in the database, and then&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Visits the &lt;code&gt;new_post_path&lt;/code&gt; url.&lt;br&gt;&lt;/li&gt;
&lt;li&gt;We should be shown the login form, and we fill it out&lt;/li&gt;
&lt;li&gt;Click the log in button&lt;/li&gt;
&lt;li&gt;Fill out the new post form&lt;/li&gt;
&lt;li&gt;Create the post&lt;/li&gt;
&lt;li&gt;Make sure that it&amp;#39;s in the database&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you want to skip the steps of manually logging in the user, you can use the &lt;code&gt;login_as&lt;/code&gt; method like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  it &amp;quot;should create a new post with a logged in user&amp;quot; do
    login_as create( :user ), scope: :user

    visit new_post_path
    # puts page.body

    within &amp;quot;#new_post&amp;quot; do
      fill_in &amp;quot;post_name&amp;quot;, with: &amp;quot;Post title&amp;quot;
    end

    click_link_or_button &amp;quot;Create Post&amp;quot;

    expect( Post.count ).to eq(1)
    expect( Post.first.name).to eq( &amp;quot;Post title&amp;quot;)

  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="setting-up-webmock-and-vcr"&gt;Setting up webmock and VCR&lt;/h2&gt;

&lt;p&gt;Webmock stops requests from hitting the network in the test environment.  Lets turn this on by editing &lt;code&gt;rails_helper.rb&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;rails_helper.rb&lt;/code&gt;, below &lt;code&gt;require &amp;#39;rails/rspec&amp;#39;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;webmock/rspec&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And VCR lets you record and play back tests in the test environment, so the first time it&amp;#39;s called it lets it get through, and then on subsequent requests it plays back a known response.  Put this at the bottom of &lt;code&gt;rails_helper.rb&lt;/code&gt; to configure:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;VCR.configure do |c|
  c.cassette_library_dir  = Rails.root.join(&amp;quot;spec&amp;quot;, &amp;quot;vcr&amp;quot;)
  c.hook_into :webmock
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="example-usage-of-webmock-and-vcr"&gt;Example usage of webmock and VCR&lt;/h2&gt;

&lt;p&gt;Word comes down from up high that to facilitate decision making, a key bit of information is the current phase of the moon when something is posted to the site.  We can pull the data from the &lt;a href="http://cerridwen.readthedocs.org/en/latest/index.html"&gt;Cerridwen&lt;/a&gt; site, but how do we set up tests for this?  We certainly don&amp;#39;t want our test suite to fail because the phase of the moon changed!&lt;/p&gt;

&lt;p&gt;This is where webmock and VCR comes in.  Webmock by itself will throw an error when a request is made over the network.  VCR will let us record and play back network request -- using &lt;em&gt;cassettes&lt;/em&gt; no less -- so that we isolate changing API responses from our tests.&lt;/p&gt;

&lt;p&gt;First lets write our code to look up the phase of the moon on the create post action.  Let&amp;#39;s add a field&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;$ rails g migration add_phase_of_moon_to_posts moon_phase:string &amp;amp;&amp;amp; rake db:migrat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the lookup to our &lt;code&gt;app/controllers/posts_controller.rb&lt;/code&gt; and replace the &lt;code&gt;def create&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  require &amp;#39;json&amp;#39;
  require &amp;#39;net/http&amp;#39;
  def create
    @post = Post.new(post_params)

    moon_json = Net::HTTP.get( URI.parse(&amp;quot;http://cerridwen.viridian-project.de/api/v1/moon&amp;quot; ))
    moon = JSON.parse( moon_json ).first

    @post.moon_phase = &amp;quot;#{moon[&amp;#39;phase&amp;#39;][&amp;#39;trend&amp;#39;]} in #{moon[&amp;#39;position&amp;#39;][&amp;#39;sign&amp;#39;]}&amp;quot;

    @post.save
    respond_with(@post)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This is not good style.)&lt;/p&gt;

&lt;p&gt;Now lets run our test again.&lt;/p&gt;

&lt;p&gt;Lots of unhandled http request errors!  I&amp;#39;m going to ignore the scaffold generate tests and focus on our rspec feature.  So, inside of &lt;code&gt;spec/features/add_new_posts_spec.rb&lt;/code&gt; we can link the click action inside of a use_cassette block like so::&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  it &amp;quot;should create a new post with a logged in user&amp;quot; do
    login_as create( :user ), scope: :user

    visit new_post_path
    # puts page.body

    within &amp;quot;#new_post&amp;quot; do
      fill_in &amp;quot;post_name&amp;quot;, with: &amp;quot;Post title&amp;quot;
    end

    VCR.use_cassette &amp;quot;waxing_in_pisces&amp;quot; do
      click_link_or_button &amp;quot;Create Post&amp;quot;

      expect( Post.count ).to eq(1)
      expect( Post.first.name).to eq( &amp;quot;Post title&amp;quot;)
      expect( Post.first.moon_phase).to eq( &amp;quot;waxing in Pisces&amp;quot; )
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And let the tests run.  When tests are run, VCR is going to look for the file &lt;code&gt;spec/vcr/waxing_in_pisces&lt;/code&gt;.  If it&amp;#39;s not found, then it will make the request to the server.  If the API requires authentication, for example an accesstoken when accessing a OAuth protected call, then you&amp;#39;ll need to configure you tests to have valid credentials for the first time.  These credentials could be written into the spec/vcr directory, so make sure that you scrub that before things get checked in.  (Or expire the access tokens.)&lt;/p&gt;

&lt;p&gt;If it is found, then it plays it back and so the next time the suite is run it plays it back.  Which is way faster.&lt;/p&gt;

&lt;h2 id="final-notes"&gt;Final notes&lt;/h2&gt;

&lt;p&gt;Testing has a place in software development, but it&amp;#39;s not actually clear where that is.  Setting up test haresses and building out tests for every feature really slows things down in the beginning, and probably isn&amp;#39;t appropriate for one off, exploratory things.  On the other hand, things tend to grow way past what anyone ever initially expected, and you always say &amp;quot;I wish there was a test suite&amp;quot; when inheriting code -- or even more likely, looking at something you haven&amp;#39;t seen for a few months.&lt;/p&gt;

&lt;p&gt;The rails community has a &lt;a href="http://martinfowler.com/articles/is-tdd-dead/"&gt;long history with Test Driven Development&lt;/a&gt;.  The biggest advantage of this is that you write code that is testable, and code that is testable has all sorts of other qualities that is great, from clearly defined boundries of responsibility, good encapulation, and being able to look at small isolated pieces of the system and having it make sense.  On the other hand, thebest code is the stuff you don&amp;#39;t need to maintain, and in some projects the weight of the test code is as large or larger than the code for the application features.&lt;/p&gt;

&lt;p&gt;The biggest problem with testing is that it gets you in a wonderful, but wrong, flow state of development.  In the begining of projects you should be focused on the user experience, and how the system is experienced from the outside.  The highest level tests tend to be are user stories, which is below the level of brand and user experience.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Setting up Devise with Twitter and Facebook and other Omniauth schemes without email addresses</title>
    <link rel="alternate" href="http://willschenk.com/setting-up-devise-with-twitter-and-facebook-and-other-omniauth-schemes-without-email-addresses/"/>
    <id>http://willschenk.com/setting-up-devise-with-twitter-and-facebook-and-other-omniauth-schemes-without-email-addresses/</id>
    <published>2015-01-15T19:00:00-05:00</published>
    <updated>2015-01-15T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Adding social login to your sites really makes it easier to get users onboard.  Devise is great to help get an authentication system up and running, but there are a few tricky things to get right.  The first challenge is that you don&amp;#39;t always get the user&amp;#39;s email address when the first connect.  The second challenge is that we want to request the minimum permissions first so that the user is more likely to sign up, and gradually ask more as the time arises.&lt;/p&gt;

&lt;p&gt;This post is going to go through the strategy that &lt;a href="http://seed.happyfuncorp.com"&gt;happy_seed&lt;/a&gt; uses to support these use cases.  The easiest way to get started is to use seed to get things up and running, but we&amp;#39;ll walk through how to do it all in detail below.&lt;/p&gt;

&lt;h2 id="install-devise-and-omniauth"&gt;Install devise and omniauth&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s install a few gems.  We&amp;#39;ll go through how to install twitter, facebook, and google.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;#39;devise&amp;#39;, &amp;#39;~&amp;gt; 3.4&amp;#39;
gem &amp;#39;omniauth&amp;#39;
gem &amp;#39;omniauth-twitter&amp;#39;
gem &amp;#39;omniauth-facebook&amp;#39;
gem &amp;#39;omniauth-instagram&amp;#39;
gem &amp;#39;twitter&amp;#39;
gem &amp;#39;instagram&amp;#39;
gem &amp;#39;omniauth-google-oauth2&amp;#39;
gem &amp;#39;google-api-client&amp;#39;, require: &amp;#39;google/api_client&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to run the &lt;code&gt;devise&lt;/code&gt; generators.  I like to copy over the views so that I can fix them up to look like the rest of my app.  If you are using seed, these views will be generated with &lt;code&gt;HAML&lt;/code&gt; and the &lt;code&gt;bootstrap helpers&lt;/code&gt; gem.&lt;/p&gt;

&lt;p&gt;First install devise:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails generate devise:install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;devise:install&lt;/code&gt; copies over &lt;code&gt;config/initializers/devise.rb&lt;/code&gt; and a localized message file.  We will configure devise here.  &lt;em&gt;Follow the outputed instuctions to setup flashes and mailer configs.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now create a model, call it user:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails generate devise User
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates a &lt;code&gt;User&lt;/code&gt; model and configures devise routes to use it.  We will edit both of these.&lt;/p&gt;

&lt;p&gt;Finally, copy over the views so you can style them as you need:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails generate devise:views
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="make-sure-regular-login-in-works"&gt;Make sure regular login in works&lt;/h2&gt;

&lt;p&gt;Lets create a basic controller to see if our login works:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails g controller welcome index
$ rake db:migrate
$ rails s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edit &lt;code&gt;routes.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  get &amp;#39;welcome/index&amp;#39;
  root &amp;#39;welcome#index&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And change your &lt;code&gt;WeclomeController&lt;/code&gt; to require user authentication:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class WelcomeController
  before_action :authenticate_user!

  def index
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you go to &lt;a href="http://localhost:3000/"&gt;http://localhost:3000/&lt;/a&gt; you should get redirected to a login page.  If you create a user you should be able to then see the protected page.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s add a logout button to the index page for testing: &lt;code&gt;app/views/welcome/index.html.erb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%= link_to &amp;quot;Signout&amp;quot;, destroy_user_session_path, method: :delete %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can go back and forth.  The &lt;code&gt;method: :delete&lt;/code&gt; part is something that I often forget about.&lt;/p&gt;

&lt;h2 id="configure-omniauth"&gt;Configure Omniauth&lt;/h2&gt;

&lt;p&gt;We need to tell devise and omniauth how to talk to the various outside services.  The first thing you&amp;#39;ll need to do is configure those services and collect their app ids and app secrets.  Then you put that information inside of &lt;code&gt;config/initializers/devise.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;    config.omniauth :google_oauth2, ENV[&amp;#39;GOOGLE_OAUTH2_APP_ID&amp;#39;], ENV[&amp;#39;GOOGLE_OAUTH2_APP_SECRET&amp;#39;], scope: &amp;quot;email,profile,offline&amp;quot;, prompt: &amp;quot;consent&amp;quot;
    config.omniauth :instagram, ENV[&amp;#39;INSTAGRAM_APP_ID&amp;#39;], ENV[&amp;#39;INSTAGRAM_APP_SECRET&amp;#39;]
    config.omniauth :facebook, ENV[&amp;#39;FACEBOOK_APP_ID&amp;#39;], ENV[&amp;#39;FACEBOOK_APP_SECRET&amp;#39;], scope: &amp;quot;email&amp;quot;
    config.omniauth :twitter, ENV[&amp;#39;TWITTER_APP_ID&amp;#39;], ENV[&amp;#39;TWITTER_APP_SECRET&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we are building nice &lt;a href="http://12factor.net"&gt;12 Factor Apps&lt;/a&gt; we pull the config from the environment.  seed uses the &lt;a href="https://github.com/bkeepers/dotenv"&gt;dotenv gem&lt;/a&gt; to keep track of these things in a &lt;code&gt;.env&lt;/code&gt; file, and when you deploy to heroku you will use heroku config variables.&lt;/p&gt;

&lt;p&gt;We also pass in &lt;code&gt;scope&lt;/code&gt;s to a few strategies, which is where we can configure omniauth to request specific permissions.  Sometimes you need to enable them on the remote side before you can request things (&lt;em&gt;e.g.&lt;/em&gt; google, twitter) so make sure that things are setup there.&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll go into how to dynamically set that scope later on.&lt;/p&gt;

&lt;h2 id="tell-devise-about-omniauthable"&gt;Tell Devise about omniauthable&lt;/h2&gt;

&lt;p&gt;Open up &lt;code&gt;app/models/user.rb&lt;/code&gt; and add &lt;code&gt;:omniauthable&lt;/code&gt; to your &lt;code&gt;devise&lt;/code&gt; line and remove &lt;code&gt;:validatable&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  devise :omniauthable, :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should see that there are a list of connect with our services when you go to your sign in or login pages.&lt;/p&gt;

&lt;h2 id="create-a-formuser-to-handle-validations"&gt;Create a FormUser to handle validations&lt;/h2&gt;

&lt;p&gt;Not all services return email addresses, and by default the devise validations expect them.  Let&amp;#39;s move those validations out of the base &lt;code&gt;User&lt;/code&gt; class into a &lt;code&gt;FormUser&lt;/code&gt; class.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remove &lt;code&gt;:validatable&lt;/code&gt; from &lt;code&gt;app/models/user.rb&lt;/code&gt; (which you&amp;#39;ve done above)&lt;/li&gt;
&lt;li&gt;Tell devise to use our new model.&lt;/li&gt;
&lt;li&gt;Create the forms_user.rb class.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Inside of &lt;code&gt;config/routes.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;devise_for :users, class_name: &amp;#39;FormUser&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And &lt;code&gt;app/models/form_user.rb&lt;/code&gt; should look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class FormUser &amp;lt; User
  attr_accessor :current_password

  validates_presence_of   :email, if: :email_required?
  validates_uniqueness_of :email, allow_blank: true, if: :email_changed?
  validates_format_of     :email, with: Devise.email_regexp, allow_blank: true, if: :email_changed?

  validates_presence_of     :password, if: :password_required?
  validates_confirmation_of :password, if: :password_required?
  validates_length_of       :password, within: Devise.password_length, allow_blank: true

  def password_required?
    return false if email.blank?
    !persisted? || !password.nil? || !password_confirmation.nil?
  end

  def email_required?
    true
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;class_name&lt;/code&gt; inside of the devise config will tell it to use this class for building forms, and we have the validations on this class so our error messages will work on the site, but we&amp;#39;ll be able to save objects without it.&lt;/p&gt;

&lt;h2 id="create-identity-model-to-store-access_keys-and-metadata"&gt;Create Identity model to store access_keys and metadata&lt;/h2&gt;

&lt;p&gt;Now we are ready to plug in oauth authentications.  The flow is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;User requests &lt;code&gt;/users/auth/:provider&lt;/code&gt;, where provider one of the strategies that you defined above.&lt;/li&gt;
&lt;li&gt;Omniauth does magic and directs the user to the remote service.&lt;/li&gt;
&lt;li&gt;The user grants us access and is redirected to the callback path.&lt;/li&gt;
&lt;li&gt;The OmniauthCallbacks controller is called on our application with the relavent info.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will use this info to create the user.  We are also going to store it to be able to access the service on behalf of the user, and we&amp;#39;ll need to store the &lt;code&gt;access_token&lt;/code&gt; in order to do so.&lt;/p&gt;

&lt;p&gt;Google is slightly more complicated and we&amp;#39;ll need to store a &lt;code&gt;refresh_token&lt;/code&gt; as well.&lt;/p&gt;

&lt;p&gt;Lets create that model now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rails model identity user:references provider:string accesstoken:string refreshtoken:string uid:string name:string email:string nickname:string image:string phone:string urls:string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And flesh out &lt;code&gt;app/models/identity.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class Identity &amp;lt; ActiveRecord::Base
  belongs_to :user
  validates_presence_of :uid, :provider
  validates_uniqueness_of :uid, :scope =&amp;gt; :provider

  def self.find_for_oauth(auth)
    identity = find_by(provider: auth.provider, uid: auth.uid)
    identity = create(uid: auth.uid, provider: auth.provider) if identity.nil?
    identity.accesstoken = auth.credentials.token
    identity.refreshtoken = auth.credentials.refresh_token
    identity.name = auth.info.name
    identity.email = auth.info.email
    identity.nickname = auth.info.nickname
    identity.image = auth.info.image
    identity.phone = auth.info.phone
    identity.urls = (auth.info.urls || &amp;quot;&amp;quot;).to_json
    identity.save
    identity
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to tell devise to use this model.&lt;/p&gt;

&lt;h2 id="create-omniauthcallbackscontroller-to-pull-in-data"&gt;Create OmniauthCallbacksController to pull in data&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re going to build one method to handle the different authentication callbacks, called &lt;code&gt;generic_callback&lt;/code&gt;.  The logic of this controller is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Find or create an &lt;code&gt;Identity&lt;/code&gt; object for the incoming oauth data.  Update it with the latest info.&lt;/li&gt;
&lt;li&gt;If there is no user associated with the Identity, associate it with the current_user.&lt;/li&gt;
&lt;li&gt;If there is no current_user, create a new User object.&lt;/li&gt;
&lt;li&gt;If the User object doesn&amp;#39;t have an email address set yet, but we do have one from the remote service, set the email address to that.&lt;/li&gt;
&lt;li&gt;Log the user in and let the continue on their way.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;First we need to tell devise about our controller in &lt;code&gt;routes.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;devise_for :users, class_name: &amp;#39;FormUser&amp;#39;, :controllers =&amp;gt; { omniauth_callbacks: &amp;#39;omniauth_callbacks&amp;#39; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create &lt;code&gt;app/controllers/omniauth_callback_controller.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class OmniauthCallbacksController &amp;lt; Devise::OmniauthCallbacksController
  def instagram
    generic_callback( &amp;#39;instagram&amp;#39; )
  end

  def facebook
    generic_callback( &amp;#39;facebook&amp;#39; )
  end

  def twitter
    generic_callback( &amp;#39;twitter&amp;#39; )
  end

  def google_oauth2
    generic_callback( &amp;#39;google_oauth2&amp;#39; )
  end

  def generic_callback( provider )
    @identity = Identity.find_for_oauth env[&amp;quot;omniauth.auth&amp;quot;]

    @user = @identity.user || current_user
    if @user.nil?
      @user = User.create( email: @identity.email || &amp;quot;&amp;quot; )
      @identity.update_attribute( :user_id, @user.id )
    end

    if @user.email.blank? &amp;amp;&amp;amp; @identity.email
      @user.update_attribute( :email, @identity.email)
    end

    if @user.persisted?
      @identity.update_attribute( :user_id, @user.id )
      # This is because we&amp;#39;ve created the user manually, and Device expects a
      # FormUser class (with the validations)
      @user = FormUser.find @user.id
      sign_in_and_redirect @user, event: :authentication
      set_flash_message(:notice, :success, kind: provider.capitalize) if is_navigational_format?
    else
      session[&amp;quot;devise.#{provider}_data&amp;quot;] = env[&amp;quot;omniauth.auth&amp;quot;]
      redirect_to new_user_registration_url
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="override-registrationscontroller-to-handle-adding-email-address-and-password"&gt;Override RegistrationsController to handle adding email address and password&lt;/h2&gt;

&lt;p&gt;We want to let the user add an email address if they haven&amp;#39;t already, and also let them set a password if they haven&amp;#39;t already set one.  (Otherwise it requires the user to enter in &lt;code&gt;current_password&lt;/code&gt;.)  Lets first tell devise about our new controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;devise_for :users, class_name: &amp;#39;FormUser&amp;#39;, :controllers =&amp;gt; { omniauth_callbacks: &amp;#39;omniauth_callbacks&amp;#39;, registrations: &amp;#39;registrations&amp;#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then create that controller:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class RegistrationsController &amp;lt; Devise::RegistrationsController
  def update_resource(resource, params)
    if resource.encrypted_password.blank? # || params[:password].blank?
      resource.email = params[:email] if params[:email]
      if !params[:password].blank? &amp;amp;&amp;amp; params[:password] == params[:password_confirmation]
        logger.info &amp;quot;Updating password&amp;quot;
        resource.password = params[:password]
        resource.save
      end
      if resource.valid?
        resource.update_without_password(params)
      end
    else
      resource.update_with_password(params)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we should be good!  Give it a go and see how it looks!&lt;/p&gt;

&lt;h2 id="adding-methods-to-user-to-get-to-the-clients"&gt;Adding methods to User to get to the clients&lt;/h2&gt;

&lt;p&gt;This goes into &lt;code&gt;app/models/users.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  has_many :identities

  def twitter
    identities.where( :provider =&amp;gt; &amp;quot;twitter&amp;quot; ).first
  end

  def twitter_client
    @twitter_client ||= Twitter.client( access_token: twitter.accesstoken )
  end

  def facebook
    identities.where( :provider =&amp;gt; &amp;quot;facebook&amp;quot; ).first
  end

  def facebook_client
    @facebook_client ||= Facebook.client( access_token: facebook.accesstoken )
  end

  def instagram
    identities.where( :provider =&amp;gt; &amp;quot;instagram&amp;quot; ).first
  end

  def instagram_client
    @instagram_client ||= Instagram.client( access_token: instagram.accesstoken )
  end

  def google_oauth2
    identities.where( :provider =&amp;gt; &amp;quot;google_oauth2&amp;quot; ).first
  end

  def google_oauth2_client
    if !@google_oauth2_client
      @google_oauth2_client = Google::APIClient.new(:application_name =&amp;gt; &amp;#39;HappySeed App&amp;#39;, :application_version =&amp;gt; &amp;quot;1.0.0&amp;quot; )
      @google_oauth2_client.authorization.update_token!({:access_token =&amp;gt; google_oauth2.accesstoken, :refresh_token =&amp;gt; google_oauth2.refreshtoken})
    end
    @google_oauth2_client
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you can access a configured API client using things like &lt;code&gt;current_user.twitter&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="passing-dynamic-scopes-to-omniauth"&gt;Passing dynamic scopes to omniauth&lt;/h2&gt;

&lt;p&gt;In the current scheme above, you have to hard code the scopes that you want to request for the user which doesn&amp;#39;t always work.  It would be better to only request write access if the user really needs to have it, and by default only get read-only access.  In order to do this we can leverage the &lt;code&gt;Omniauth&lt;/code&gt; setup property.  Inside of &lt;code&gt;devise.rb&lt;/code&gt; add &lt;code&gt;setup: true&lt;/code&gt; to each of the services you want to be able to upgrade.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;    config.omniauth :google_oauth2, ENV[&amp;#39;GOOGLE_OAUTH2_APP_ID&amp;#39;], ENV[&amp;#39;GOOGLE_OAUTH2_APP_SECRET&amp;#39;], scope: &amp;quot;email,profile,offline&amp;quot;, prompt: &amp;quot;consent&amp;quot;, setup: true
    config.omniauth :instagram, ENV[&amp;#39;INSTAGRAM_APP_ID&amp;#39;], ENV[&amp;#39;INSTAGRAM_APP_SECRET&amp;#39;], setup: true
    config.omniauth :facebook, ENV[&amp;#39;FACEBOOK_APP_ID&amp;#39;], ENV[&amp;#39;FACEBOOK_APP_SECRET&amp;#39;], scope: &amp;quot;email&amp;quot;, setup: true
    config.omniauth :twitter, ENV[&amp;#39;TWITTER_APP_ID&amp;#39;], ENV[&amp;#39;TWITTER_APP_SECRET&amp;#39;], setup: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s add a few routes in &lt;code&gt;routes.rb&lt;/code&gt; that we can have the user link to:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  devise_scope :user do
    get &amp;#39;/users/auth/:provider/upgrade&amp;#39; =&amp;gt; &amp;#39;omniauth_callbacks#upgrade&amp;#39;, as: :user_omniauth_upgrade
    get &amp;#39;/users/auth/:provider/setup&amp;#39;, :to =&amp;gt; &amp;#39;omniauth_callbacks#setup&amp;#39;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first route is something that we&amp;#39;ll have the user link to, using &lt;code&gt;user_omniauth_upgrade_path( :google_oauth2 )&lt;/code&gt; for example.  The second &lt;code&gt;setup&lt;/code&gt; route is what omniauth will call internally that we can use to change the &lt;code&gt;scope&lt;/code&gt; parameter.  These go into &lt;code&gt;omniauth_callbacks_controller.rb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first &lt;code&gt;upgrade&lt;/code&gt; method looks at the provider and sets a &lt;code&gt;flash&lt;/code&gt; variable for the additional access.  In this case, we are asking for the &lt;code&gt;https://www.googleapis.com/auth/admin.directory.user&lt;/code&gt; also.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def upgrade
    scope = nil
    if params[:provider] == &amp;quot;google_oauth2&amp;quot;
      scope = &amp;quot;email,profile,offline,https://www.googleapis.com/auth/admin.directory.user&amp;quot;
    end

    redirect_to user_omniauth_authorize_path( params[:provider] ), flash: { scope: scope }
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it directs the user back to the normal flow.&lt;/p&gt;

&lt;p&gt;When you specify &lt;code&gt;setup: true&lt;/code&gt; inside of the omniauth configuration, there is magic that calls the &lt;code&gt;setup_path&lt;/code&gt; by default, and this is the method where we change the scope from the default in the strategy:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def setup
    request.env[&amp;#39;omniauth.strategy&amp;#39;].options[&amp;#39;scope&amp;#39;] = flash[:scope] || request.env[&amp;#39;omniauth.strategy&amp;#39;].options[&amp;#39;scope&amp;#39;]
    render :text =&amp;gt; &amp;quot;Setup complete.&amp;quot;, :status =&amp;gt; 404
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now in your views, you can do&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%= link_to &amp;quot;Upgrade Access&amp;quot;, user_omniauth_upgrade_path( :google_oauth2 ) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the user will go through the oauth flow again requesting the additional access.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Making all of this work is possible, but there are a lot of fiddly little bits to make it work.  Both devise and all of the many omniauth strategies out there make it easy to add this functionality to your application.&lt;/p&gt;

&lt;p&gt;Check out &lt;a href="http://seed.happyfuncorp.com"&gt;seed&lt;/a&gt; to quickly create an application will all of this stuff done for you!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Using rake for dataflow programming and data science</title>
    <link rel="alternate" href="http://willschenk.com/using-rake-for-dataflow-programming-and-data-science/"/>
    <id>http://willschenk.com/using-rake-for-dataflow-programming-and-data-science/</id>
    <published>2014-12-18T19:00:00-05:00</published>
    <updated>2014-12-18T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;#39;ve been using Rake more and more for data collection and processing tasks.  Rake is pretty pretty powerful.  Most people know it as way to add external tasks to a Rails app, but it&amp;#39;s actually very powerful build system.  We&amp;#39;re going to take advantage of that to build out a &lt;a href="https://github.com/HappyFunCorp/rake-data"&gt;framework&lt;/a&gt; that will make it easy to collect, process, and interpret data while keeping it all in sync.&lt;/p&gt;

&lt;p&gt;In fact, if you just want to start playing with stuff now, head over to the &lt;a href="https://github.com/HappyFunCorp/rake-data"&gt;rake-data&lt;/a&gt; site to go through some walk throughs.  Read on to setup a fun world of your own!&lt;/p&gt;

&lt;h2 id="rejected-titles-of-this-post"&gt;Rejected titles of this post&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;rake and bake&lt;/li&gt;
&lt;li&gt;rake me up before you go-go&lt;/li&gt;
&lt;li&gt;let them eat rake&lt;/li&gt;
&lt;li&gt;rake it until you make it&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id="tasks-and-dependancies"&gt;Tasks and Dependancies&lt;/h2&gt;

&lt;p&gt;Rake is a a Make-like Ruby program that people know mostly in terms of rails apps.  We can define a few tasks and define their interdependancies:&lt;/p&gt;

&lt;div class="diagram_right"&gt;
&lt;svg width="291pt" height="188pt" viewBox="0.00 0.00 291.36 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"&gt;&lt;title&gt;G&lt;/title&gt;&lt;polygon fill="white" stroke="none" points="-4,4 -4,-184 287.355,-184 287.355,4 -4,4"/&gt;&lt;!-- a --&gt;&lt;g id="node1" class="node"&gt;&lt;title&gt;a&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="93.105" cy="-162" rx="93.2101" ry="18"/&gt;&lt;text text-anchor="middle" x="93.105" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;mail daily leaderboards&lt;/text&gt;&lt;/g&gt;&lt;!-- b --&gt;&lt;g id="node2" class="node"&gt;&lt;title&gt;b&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="93.105" cy="-90" rx="83.0546" ry="18"/&gt;&lt;text text-anchor="middle" x="93.105" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;update leader boards&lt;/text&gt;&lt;/g&gt;&lt;!-- a&amp;#45;&amp;gt;b --&gt;&lt;g id="edge1" class="edge"&gt;&lt;title&gt;a&amp;#45;&amp;gt;b&lt;/title&gt;&lt;path fill="none" stroke="black" d="M93.105,-143.697C93.105,-135.983 93.105,-126.712 93.105,-118.112"/&gt;&lt;polygon fill="black" stroke="black" points="96.6051,-118.104 93.105,-108.104 89.6051,-118.104 96.6051,-118.104"/&gt;&lt;/g&gt;&lt;!-- c --&gt;&lt;g id="node3" class="node"&gt;&lt;title&gt;c&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="166.105" cy="-18" rx="54.6076" ry="18"/&gt;&lt;text text-anchor="middle" x="166.105" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;environment&lt;/text&gt;&lt;/g&gt;&lt;!-- b&amp;#45;&amp;gt;c --&gt;&lt;g id="edge2" class="edge"&gt;&lt;title&gt;b&amp;#45;&amp;gt;c&lt;/title&gt;&lt;path fill="none" stroke="black" d="M110.776,-72.055C120.057,-63.1558 131.574,-52.1121 141.693,-42.4085"/&gt;&lt;polygon fill="black" stroke="black" points="144.304,-44.7545 149.099,-35.307 139.459,-39.702 144.304,-44.7545"/&gt;&lt;/g&gt;&lt;!-- d --&gt;&lt;g id="node4" class="node"&gt;&lt;title&gt;d&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="239.105" cy="-90" rx="44.0015" ry="18"/&gt;&lt;text text-anchor="middle" x="239.105" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;flush data&lt;/text&gt;&lt;/g&gt;&lt;!-- d&amp;#45;&amp;gt;c --&gt;&lt;g id="edge3" class="edge"&gt;&lt;title&gt;d&amp;#45;&amp;gt;c&lt;/title&gt;&lt;path fill="none" stroke="black" d="M222.54,-73.1159C213.062,-64.0273 200.997,-52.458 190.457,-42.3513"/&gt;&lt;polygon fill="black" stroke="black" points="192.751,-39.702 183.111,-35.307 187.906,-44.7545 192.751,-39.702"/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class="rb"&gt;task :mail_daily_leader_boards =&amp;gt; :update_leader_boards do
  User.mail_leader_boards!
end

task :flush_data =&amp;gt; :environment do
  Leaderboard.flush!
end

task :update_leader_boards =&amp;gt; :environment do
  Leaderboard.update!
end

task :environment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run &lt;code&gt;mail_daily_leaderboards&lt;/code&gt; it makes sure that &lt;code&gt;update_leader_boards&lt;/code&gt; is run first.  This in turn depends upon &lt;code&gt;environment&lt;/code&gt;, and Rake makes sure that all dependancies are met before executing the task.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake mail_daily_leaderboards --dry-run
** Invoke mail_daily_leader_boards (first_time)
** Invoke update_leader_boards (first_time)
** Invoke environment (first_time)
** Execute (dry run) environment
** Execute (dry run) update_leader_boards
** Execute (dry run) mail_daily_leader_boards
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rake is also smart enough to only run a task once.  Lets look at what happens when we try to run two tasks:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake flush_data mail_daily_leader_boards --dry-run
** Invoke flush_data (first_time)
** Invoke environment (first_time)
** Execute (dry run) environment
** Execute (dry run) flush_data
** Invoke mail_daily_leader_boards (first_time)
** Invoke update_leader_boards (first_time)
** Invoke environment 
** Execute (dry run) update_leader_boards
** Execute (dry run) mail_daily_leader_boards
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice here that even though &lt;code&gt;update_leader_boards&lt;/code&gt; and &lt;code&gt;flush_data&lt;/code&gt; both depend on &lt;code&gt;environment&lt;/code&gt;, so it needs to be run for either of the dependant tasks to run, and it is only invoked once.&lt;/p&gt;

&lt;p&gt;So far so good.&lt;/p&gt;

&lt;h2 id="dataflow-programming"&gt;Dataflow programming&lt;/h2&gt;

&lt;p&gt;So Rake gives us a dependancy specification and resolution process.  We can visualize this in two ways.  One way is where the arrows are pointing to sub tasks, top down, where the arrow direction represents the control flow control of the process.  When you want A, it makes sure that B and C are there, which in turn have their own dependancies.&lt;/p&gt;

&lt;p&gt;What does it mean if we were to reverse the arrows on the graph?&lt;/p&gt;

&lt;table class="table table-bordered"&gt;
  &lt;tr&gt;
    &lt;th style="text-align: center"&gt;Top Down&lt;/th&gt;
    &lt;th style="text-align: center"&gt;Bottom Up&lt;/th&gt;
  &lt;/tr&gt;

  &lt;tr&gt;
    &lt;td style="text-align: center"&gt;
&lt;svg width="134pt" height="188pt" viewBox="0.00 0.00 134.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"&gt;&lt;title&gt;%3&lt;/title&gt;&lt;polygon fill="white" stroke="none" points="-4,4 -4,-184 130,-184 130,4 -4,4"/&gt;&lt;!-- A --&gt;&lt;g id="node1" class="node"&gt;&lt;title&gt;A&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="63" cy="-162" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="63" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;A&lt;/text&gt;&lt;/g&gt;&lt;!-- B --&gt;&lt;g id="node2" class="node"&gt;&lt;title&gt;B&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;B&lt;/text&gt;&lt;/g&gt;&lt;!-- A&amp;#45;&amp;gt;B --&gt;&lt;g id="edge1" class="edge"&gt;&lt;title&gt;A&amp;#45;&amp;gt;B&lt;/title&gt;&lt;path fill="none" stroke="black" d="M54.6504,-144.765C50.2885,-136.283 44.8531,-125.714 39.9587,-116.197"/&gt;&lt;polygon fill="black" stroke="black" points="42.9904,-114.439 35.3043,-107.147 36.7654,-117.641 42.9904,-114.439"/&gt;&lt;/g&gt;&lt;!-- C --&gt;&lt;g id="node3" class="node"&gt;&lt;title&gt;C&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;C&lt;/text&gt;&lt;/g&gt;&lt;!-- A&amp;#45;&amp;gt;C --&gt;&lt;g id="edge2" class="edge"&gt;&lt;title&gt;A&amp;#45;&amp;gt;C&lt;/title&gt;&lt;path fill="none" stroke="black" d="M71.3496,-144.765C75.7115,-136.283 81.1469,-125.714 86.0413,-116.197"/&gt;&lt;polygon fill="black" stroke="black" points="89.2346,-117.641 90.6957,-107.147 83.0096,-114.439 89.2346,-117.641"/&gt;&lt;/g&gt;&lt;!-- D --&gt;&lt;g id="node4" class="node"&gt;&lt;title&gt;D&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-18" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;D&lt;/text&gt;&lt;/g&gt;&lt;!-- B&amp;#45;&amp;gt;D --&gt;&lt;g id="edge3" class="edge"&gt;&lt;title&gt;B&amp;#45;&amp;gt;D&lt;/title&gt;&lt;path fill="none" stroke="black" d="M27,-71.6966C27,-63.9827 27,-54.7125 27,-46.1124"/&gt;&lt;polygon fill="black" stroke="black" points="30.5001,-46.1043 27,-36.1043 23.5001,-46.1044 30.5001,-46.1043"/&gt;&lt;/g&gt;&lt;!-- C&amp;#45;&amp;gt;D --&gt;&lt;g id="edge4" class="edge"&gt;&lt;title&gt;C&amp;#45;&amp;gt;D&lt;/title&gt;&lt;path fill="none" stroke="black" d="M84.4297,-74.8345C74.2501,-64.9376 60.4761,-51.5462 48.9694,-40.3591"/&gt;&lt;polygon fill="black" stroke="black" points="51.4055,-37.8461 41.7957,-33.3847 46.5259,-42.865 51.4055,-37.8461"/&gt;&lt;/g&gt;&lt;!-- E --&gt;&lt;g id="node5" class="node"&gt;&lt;title&gt;E&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-18" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;E&lt;/text&gt;&lt;/g&gt;&lt;!-- C&amp;#45;&amp;gt;E --&gt;&lt;g id="edge5" class="edge"&gt;&lt;title&gt;C&amp;#45;&amp;gt;E&lt;/title&gt;&lt;path fill="none" stroke="black" d="M99,-71.6966C99,-63.9827 99,-54.7125 99,-46.1124"/&gt;&lt;polygon fill="black" stroke="black" points="102.5,-46.1043 99,-36.1043 95.5001,-46.1044 102.5,-46.1043"/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;    &lt;/td&gt;

    &lt;td style="text-align: center"&gt;
&lt;svg width="134pt" height="188pt" viewBox="0.00 0.00 134.00 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"&gt;&lt;title&gt;%3&lt;/title&gt;&lt;polygon fill="white" stroke="none" points="-4,4 -4,-184 130,-184 130,4 -4,4"/&gt;&lt;!-- E --&gt;&lt;g id="node1" class="node"&gt;&lt;title&gt;E&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-162" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;E&lt;/text&gt;&lt;/g&gt;&lt;!-- C --&gt;&lt;g id="node2" class="node"&gt;&lt;title&gt;C&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="27" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="27" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;C&lt;/text&gt;&lt;/g&gt;&lt;!-- E&amp;#45;&amp;gt;C --&gt;&lt;g id="edge1" class="edge"&gt;&lt;title&gt;E&amp;#45;&amp;gt;C&lt;/title&gt;&lt;path fill="none" stroke="black" d="M27,-143.697C27,-135.983 27,-126.712 27,-118.112"/&gt;&lt;polygon fill="black" stroke="black" points="30.5001,-118.104 27,-108.104 23.5001,-118.104 30.5001,-118.104"/&gt;&lt;/g&gt;&lt;!-- A --&gt;&lt;g id="node5" class="node"&gt;&lt;title&gt;A&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="63" cy="-18" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="63" y="-13.8" font-family="Times,serif" font-size="14.00"&gt;A&lt;/text&gt;&lt;/g&gt;&lt;!-- C&amp;#45;&amp;gt;A --&gt;&lt;g id="edge4" class="edge"&gt;&lt;title&gt;C&amp;#45;&amp;gt;A&lt;/title&gt;&lt;path fill="none" stroke="black" d="M35.3496,-72.7646C39.7115,-64.2831 45.1469,-53.7144 50.0413,-44.1974"/&gt;&lt;polygon fill="black" stroke="black" points="53.2346,-45.6409 54.6957,-35.1473 47.0096,-42.4395 53.2346,-45.6409"/&gt;&lt;/g&gt;&lt;!-- D --&gt;&lt;g id="node3" class="node"&gt;&lt;title&gt;D&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-162" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-157.8" font-family="Times,serif" font-size="14.00"&gt;D&lt;/text&gt;&lt;/g&gt;&lt;!-- D&amp;#45;&amp;gt;C --&gt;&lt;g id="edge2" class="edge"&gt;&lt;title&gt;D&amp;#45;&amp;gt;C&lt;/title&gt;&lt;path fill="none" stroke="black" d="M84.4297,-146.834C74.2501,-136.938 60.4761,-123.546 48.9694,-112.359"/&gt;&lt;polygon fill="black" stroke="black" points="51.4055,-109.846 41.7957,-105.385 46.5259,-114.865 51.4055,-109.846"/&gt;&lt;/g&gt;&lt;!-- B --&gt;&lt;g id="node4" class="node"&gt;&lt;title&gt;B&lt;/title&gt;&lt;ellipse fill="none" stroke="black" cx="99" cy="-90" rx="27" ry="18"/&gt;&lt;text text-anchor="middle" x="99" y="-85.8" font-family="Times,serif" font-size="14.00"&gt;B&lt;/text&gt;&lt;/g&gt;&lt;!-- D&amp;#45;&amp;gt;B --&gt;&lt;g id="edge3" class="edge"&gt;&lt;title&gt;D&amp;#45;&amp;gt;B&lt;/title&gt;&lt;path fill="none" stroke="black" d="M99,-143.697C99,-135.983 99,-126.712 99,-118.112"/&gt;&lt;polygon fill="black" stroke="black" points="102.5,-118.104 99,-108.104 95.5001,-118.104 102.5,-118.104"/&gt;&lt;/g&gt;&lt;!-- B&amp;#45;&amp;gt;A --&gt;&lt;g id="edge5" class="edge"&gt;&lt;title&gt;B&amp;#45;&amp;gt;A&lt;/title&gt;&lt;path fill="none" stroke="black" d="M90.6504,-72.7646C86.2885,-64.2831 80.8531,-53.7144 75.9587,-44.1974"/&gt;&lt;polygon fill="black" stroke="black" points="78.9904,-42.4395 71.3043,-35.1473 72.7654,-45.6409 78.9904,-42.4395"/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;If we think about rake in terms of managing a build process, what we called &lt;em&gt;dependancies&lt;/em&gt; are actually the source of the data.  If we want an object file, we start with the source file.  If we want to generate C, we need to have generated the data for D and E.&lt;/p&gt;

&lt;h2 id="file-tasks"&gt;File Tasks&lt;/h2&gt;

&lt;p&gt;Rake also knows about building files.  &lt;code&gt;Rake::FileTask&lt;/code&gt; is a subtask of &lt;code&gt;Rake::Task&lt;/code&gt; which will only run the target if the &lt;em&gt;file is out of date&lt;/em&gt; : if the source file is newer than the destination file.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;file &amp;quot;Rakefile.gz&amp;quot; =&amp;gt; &amp;quot;Rakefile&amp;quot; do |task|
  sh &amp;quot;gzip -fkv #{task.source}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defined as task called &lt;code&gt;Rakefile.gz&lt;/code&gt; that when invoked will look to see if either the file doesn&amp;#39;t exist, or if it&amp;#39;s older than the source file &lt;code&gt;Rakefile&lt;/code&gt;, and gzips it up.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake Rakefile.gz
gzip -fkv Rakefile
Rakefile:   -20.6% -- replaced with Rakefile.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run it again and nothing happens!&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake Rakefile.gz
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Touch the source file and it gets rebuilt:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ touch Rakefile
$ rake Rakefile.gz
gzip -fkv Rakefile
Rakefile:   -20.6% -- replaced with Rakefile.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="rake-as-a-build-system"&gt;Rake as a build system&lt;/h2&gt;

&lt;p&gt;Files and rules come from Rake&amp;#39;s &lt;code&gt;make&lt;/code&gt; heritage.  We can think of regular &lt;code&gt;Task&lt;/code&gt;s as being a general sort of &lt;em&gt;action&lt;/em&gt;, meaning you are packaging up certain set of imperitives in a particular context to achieve some goal.  &lt;code&gt;FileTask&lt;/code&gt;s are a more specific type of action, where we want to generate a specific file from a specific source file.  For a full build system we want to be able to translate whole classes of files into other files, like source files into object files, or XML files into HTML files.  We use &lt;code&gt;Rules&lt;/code&gt; to set these up.&lt;/p&gt;

&lt;h2 id="tasks-defined-as-rules"&gt;Tasks defined as Rules&lt;/h2&gt;

&lt;p&gt;The third main bit of magic that Rake gives us is rules.  The file task can magically bring a file into being when invoked, but in a build process its more common to translate files with a certain extention to other files in a different extension.  The canonical example is probably compiling &lt;code&gt;.c&lt;/code&gt; source files into &lt;code&gt;.o&lt;/code&gt; objects, but since it&amp;#39;s the 21 first century lets look at how to run the Graphviz dot file to process into svg or png files.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;rule &amp;quot;.svg&amp;quot; =&amp;gt; &amp;quot;.dot&amp;quot; do |task|
  sh &amp;quot;dot -Tsvg &amp;lt; #{task.source} &amp;gt; #{task}&amp;quot;
end

rule &amp;quot;.png&amp;quot; =&amp;gt; &amp;quot;.dot&amp;quot; do |task|
  sh &amp;quot;dot -Tpng &amp;lt; #{task.source} &amp;gt; #{task}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can ask Rake to build a &lt;em&gt;type&lt;/em&gt; of file, and will look for a source file based upon the name that you request.  For example, if we were to run the command:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ rake bottom.svg
dot -Tsvg &amp;lt; bottom.dot &amp;gt; bottom.svg
$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rake would try to instantiate the file &lt;code&gt;bottom.svg&lt;/code&gt; by first requesting file called &lt;code&gt;bottom.dot&lt;/code&gt;.  Since this is part of the rake dependancy system, this could in turn be built by a seperate rake task!&lt;/p&gt;

&lt;p&gt;Note that Rake doesn&amp;#39;t know anything specifically about these extension.  It just knows what you have defined.  We can define other formats and build rules around that.&lt;/p&gt;

&lt;h2 id="using-rake-to-pull-data-from-a-url"&gt;Using Rake to pull data from a url&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s extend the Rake DSL to be able to download files from the internet.  You can put this at the top of your &lt;code&gt;Rakefile&lt;/code&gt; for now.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;def url( dest, source )
  file dest do
    puts &amp;quot;Loading #{source}&amp;quot;
    if !File.exists?( dest )
      mkdir_p dest.to_s.pathmap( &amp;quot;%d&amp;quot; )
      sh &amp;quot;curl -L &amp;#39;#{source}&amp;#39; &amp;gt; #{dest}&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets use this to download a file from the internet do we can parse it.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;url &amp;quot;source/weather.json&amp;quot;, &amp;quot;http://api.openweathermap.org/data/2.5/weather?id=5128581&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run &lt;code&gt;rake source/weather.json&lt;/code&gt; the first time, the file is downloaded.  The second time we run the rake command nothing happens since the &lt;code&gt;source/weather.json&lt;/code&gt; file already exists.  Lets add a quick task to parse the JSON.&lt;/p&gt;

&lt;h2 id="parse-json-using-simple-ruby-commands"&gt;Parse JSON using simple ruby commands&lt;/h2&gt;

&lt;p&gt;Lets parse the file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;json&amp;#39;
file &amp;quot;report.txt&amp;quot; =&amp;gt; &amp;quot;source/weather.json&amp;quot; do |task|
  puts &amp;quot;Parsing sun times&amp;quot;
  data = JSON.parse( File.read( task.source ))
  File.open( task.to_s, &amp;quot;wb&amp;quot; ) do |out|
    out.printf &amp;quot;%-15s %s\n&amp;quot;, &amp;#39;sunrise&amp;#39;, Time.at( data[&amp;#39;sys&amp;#39;][&amp;#39;sunrise&amp;#39;] )
    out.printf &amp;quot;%-15s %s\n&amp;quot;, &amp;#39;sunset&amp;#39;,  Time.at( data[&amp;#39;sys&amp;#39;][&amp;#39;sunset&amp;#39;] )
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run &lt;code&gt;rake report.txt&lt;/code&gt;.  This should generate the file the first time, and on subsequent runs, do nothing.  If you remove &lt;code&gt;source/weather.json&lt;/code&gt; file and run &lt;code&gt;rake report.txt&lt;/code&gt; again, you&amp;#39;ll see that Rake is smart enough to download a new version of the file.&lt;/p&gt;

&lt;h2 id="parsing-html"&gt;Parsing HTML&lt;/h2&gt;

&lt;p&gt;Another common thing to do is to download a webpage and parse through the results.  &lt;code&gt;Nokogiri&lt;/code&gt; makes this really easy since you can identify DOM elements using CSS selectors more or less the same a jQuery selectors.&lt;/p&gt;

&lt;p&gt;Lets make a function to help us parse html files into CSV files:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Parse an HTML file into CSV
def parse_html( dest, source, &amp;amp;parser )
  require &amp;#39;nokogiri&amp;#39;
  require &amp;#39;csv&amp;#39;

  file dest =&amp;gt; source do
    puts &amp;quot;Parsing #{source} -&amp;gt; #{dest}&amp;quot;
    mkdir_p dest.to_s.pathmap( &amp;quot;%d&amp;quot; )

    html = Nokogiri.parse( File.read( source ) )
    CSV.open( dest.to_s, &amp;quot;wb&amp;quot; ) do |csv|
      parser.call( html, csv )
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines a file task to convert one file type into another.  When it needs to run -- and this will only happen of the source file changes or the destination file doesnt exist -- it loads up the file into Nokogiri, creates a CSV output file, and passes control to a passed in block for processing.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s pull out a list of the top 10 popular books on project gutenberg for the last month:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Load the html file with statistics
url &amp;quot;source/top.html&amp;quot;, &amp;quot;http://www.gutenberg.org/browse/scores/top&amp;quot;

parse_html &amp;quot;processed/month_top_100.csv&amp;quot;, &amp;quot;source/top.html&amp;quot; do |html,out|
  html.css( &amp;quot;h2#books-last30 + ol a&amp;quot; ).each do |link|
    out &amp;lt;&amp;lt; [link[&amp;#39;href&amp;#39;],link.content]
  end
end

file &amp;quot;processed/month_top_10.csv&amp;quot; =&amp;gt; &amp;quot;processed/month_top_100.csv&amp;quot; do |task|
  sh &amp;quot;head -n 10 #{task.source} &amp;gt; #{task}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now run &lt;code&gt;rake processed/month_top_10.csv&lt;/code&gt; and watch what happens.  This only hits the server the first time it&amp;#39;s run.  If we want to process things again, we simply delete the files in the &lt;code&gt;source&lt;/code&gt; directory and everything in the &lt;code&gt;processed&lt;/code&gt; directory will get regenerated.&lt;/p&gt;

&lt;h2 id="tasks-over-multiple-files"&gt;Tasks over multiple files&lt;/h2&gt;

&lt;p&gt;We have a few CSV files that contain a list of books.  How would we do something with these books?  The natural thing would be to use Rake&amp;#39;s &lt;code&gt;FileList&lt;/code&gt;, but this doesn&amp;#39;t work the way you&amp;#39;d expect because &lt;code&gt;FileList&lt;/code&gt; caches its results and it therefor doesn&amp;#39;t know about files that are created during the build process.  We don&amp;#39;t want to have to run rake twice to get our results, we want to be able to trust the process!&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s extend the DSL again to add a command that will loop over a file and call our block for each line:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Loop over a file and yield the block for each line
# If name ends with .csv, parse the csv and yield each line
def file_loop( name, source )
  task name =&amp;gt; source do
    if source =~ /.csv$/
      CSV.open( source ).each do |line|
        yield line
      end
    else
      File.readlines( source ).each do |line|
        yield line
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can use this to create a task that goes through each of the lines of the file.  We&amp;#39;ll do this to define url tasks for the file and then immediately invoke them so make sure that the file was loaded.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Loop through the top ten books and make sure that they exist
file_loop &amp;quot;processed/top_10_books_text&amp;quot;, &amp;quot;processed/month_top_10.csv&amp;quot; do |line|
  path = &amp;quot;#{line[0].gsub( /^\//, &amp;quot;&amp;quot; )}.txt&amp;quot;
  puts path
  url( path, &amp;quot;http://www.gutenberg.org/#{path}.utf-8&amp;quot;)
  Rake::Task[path].invoke
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;code&gt;rake processed/top_10_books_text&lt;/code&gt; will first make sure that &lt;code&gt;processed/month_top_10.csv&lt;/code&gt; is up-to-date, doing whatever it needs too to make it happen, and then loop through each of the lines and download the ebook file.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note, we are going to be making a bunch of requests to the Project Gutenberg website, a total of 11 in all.  You might be flagged as a bot, so take a look at the generated &lt;code&gt;.txt&lt;/code&gt; files to make sure that they actually contain the book content. &lt;strong&gt;But no matter how many times you run your commands, unless you delete the downloaded files there will be no more than 11 requests to the server!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id="using-rules-to-parse-data"&gt;Using rules to parse data&lt;/h2&gt;

&lt;p&gt;Lets create a rule that will give us a count of all the words in a book:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Count and sort the list of words
rule &amp;quot;.word_count&amp;quot; =&amp;gt; &amp;quot;.words&amp;quot; do |dest|
  sh &amp;quot;cat #{dest.source} | sort | uniq -c | sort -nr&amp;gt; #{dest}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we try to run this now, say &lt;code&gt;rake ebooks/1342.word_count&lt;/code&gt; we&amp;#39;ll get an error saying it doesn&amp;#39;t know how to build that file.  Let&amp;#39;s add a rule to go from &lt;code&gt;.txt&lt;/code&gt; to &lt;code&gt;.words&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Covert txt to words
rule &amp;quot;.words&amp;quot; =&amp;gt; &amp;quot;.txt&amp;quot; do |dest|
  sh &amp;quot;cat #{dest.source} | tr -cs &amp;#39;[:alpha:]&amp;#39; &amp;#39;\n&amp;#39; | tr &amp;#39;[:upper:]&amp;#39; &amp;#39;[:lower:]&amp;#39; &amp;gt; #{dest}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we run it, we first generate a list of words, and then from that we find the unique count of them.&lt;/p&gt;

&lt;h2 id="get-your-own-rake-data"&gt;Get your own rake-data&lt;/h2&gt;

&lt;p&gt;It&amp;#39;s simple enough to setup this on your own, but I&amp;#39;ve put together a few useful things that I&amp;#39;ve been using to process data into it&amp;#39;s own gem.  You should head over to &lt;a href="https://github.com/HappyFunCorp/rake-data"&gt;https://github.com/HappyFunCorp/rake-data&lt;/a&gt; now to check it out!&lt;/p&gt;

&lt;p&gt;Other things to check out:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.kaggle.com/2012/10/15/make-for-data-scientists/"&gt;http://blog.kaggle.com/2012/10/15/make-for-data-scientists/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.factual.com/introducing-drake-a-kind-of-make-for-data"&gt;http://blog.factual.com/introducing-drake-a-kind-of-make-for-data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://datascienceatthecommandline.com"&gt;http://datascienceatthecommandline.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>Building Middleman Extensions</title>
    <link rel="alternate" href="http://willschenk.com/building-middleman-extensions/"/>
    <id>http://willschenk.com/building-middleman-extensions/</id>
    <published>2014-12-16T19:00:00-05:00</published>
    <updated>2014-12-16T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Middleman extensions, like rails plugins, are packaged as gems.  There are three main ways to extend middleman.  You can add helpers, add middleman commands, or extend the sitemap generation in someway.  Lets go through those in detail.&lt;/p&gt;

&lt;h2 id="creating-the-extension"&gt;Creating the extension&lt;/h2&gt;

&lt;p&gt;Create a gem using &lt;code&gt;bundle gem _name_&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle gem middleman-graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;middleman-core&lt;/code&gt; to your gem dependancies in the &lt;code&gt;.gemspec&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  spec.add_runtime_dependency     &amp;#39;middleman-core&amp;#39;, [&amp;#39;&amp;gt;= 3.0.0&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Register your extension into middleman.  Our gem will be activated in the sites &lt;code&gt;config.rb&lt;/code&gt; using &lt;code&gt;activate :graphviz&lt;/code&gt; and this is how middleman knows what to load.  &lt;code&gt;lib/middleman/graphviz.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman-core&amp;#39;
require &amp;quot;middleman/graphviz/version&amp;quot;
require &amp;quot;middleman/graphviz/extension&amp;quot;

::Middleman::Extensions.register(:graphviz, ::Middleman::Graphviz::Extension )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Replace with your gem name!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Write the code that actually plugs into middleman.  The we are going to add some helpers to the site, so let&amp;#39;s register them here.  Create &lt;code&gt;lib/middleman/graphviz/extension.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman/graphviz/helpers&amp;#39;

module Middleman
  module Graphviz
    class Extension &amp;lt; Middleman::Extension
      def initialize( app, options_hash = {}, &amp;amp;block)
        super

        app.helpers Middleman::Graphviz::Helpers
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Replace with your gem name!&lt;/em&gt;&lt;/p&gt;

&lt;h2 id="writing-helpers"&gt;Writing helpers&lt;/h2&gt;

&lt;p&gt;Lets create a basic helper method now in the file &lt;code&gt;lib/middleman/graphviz/helpers.rb&lt;/code&gt;. This is going to accept one parameter and a block. We are going to get the content of that block and then spit it back directly for now.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module Middleman
  module Graphviz
    module Helpers
      def basic_helper_example( param )
        &amp;quot;&amp;lt;h1&amp;gt;#{param}&amp;lt;/h1&amp;gt;&amp;quot;.html_safe
      end

      def block_helper_example( type, &amp;amp;block )
        if block_given?
          data = capture_html(&amp;amp;block)

          data = data.upcase

          concat_content(data.html_safe)
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These can be used like&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%%= basic_helper_example( &amp;quot;My Title&amp;quot;) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a block&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%% block_helper( &amp;quot;My Title&amp;quot;) do %&amp;gt;
  This is going to be in upcase
&amp;lt;%% end %%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="add-it-to-an-active-middleman-project"&gt;Add it to an active middleman project&lt;/h2&gt;

&lt;p&gt;Have bundler reference this new gem inside of an existing middleman project.  &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;quot;middleman-graphviz&amp;quot;, path: &amp;quot;../middleman-graphviz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside of the middleman project&amp;#39;s &lt;code&gt;config.rb&lt;/code&gt; activate it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;activate :graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now startup the middleman server, and use your helper in the page!  Note that, just like when you use a helper defined in &lt;code&gt;config.rb&lt;/code&gt; you need to restart &lt;code&gt;middleman server&lt;/code&gt; to see your change take effect.&lt;/p&gt;

&lt;h2 id="adding-configuration-to-your-extension"&gt;Adding configuration to your extension&lt;/h2&gt;

&lt;p&gt;If you want to include configurable options in your extension, here&amp;#39;s some skeleton code for &lt;code&gt;extension.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman/graphviz/helpers&amp;#39;

module Middleman
  module Graphviz
    cattr_accessor :options

    class Extension &amp;lt; Middleman::Extension
      def initialize( app, options_hash = {}, &amp;amp;block)
        super

        app.helpers Middleman::Graphviz::Helpers
      end

      def registered(app, options_hash = {}, &amp;amp;block)
        options = Options.new(options_hash)
        yield options if block_given?

        # Default options for the rsync method.
        options.theme ||= &amp;quot;default&amp;quot;
        options.generate_file ||= false

        ::Middleman::Graphviz.options = options

        app.helpers Middleman::Graphviz::Helpers
      end

      def after_configuration
        puts &amp;quot;After configuration&amp;quot;
      end
    end

    module Helpers
      def options
        ::Middleman::Graphviz.options
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="adding-additional-middleman-commands"&gt;Adding additional middleman commands&lt;/h2&gt;

&lt;p&gt;The middleman command is built on &lt;a href="/making-a-command-line-utility-with-gems-and-thor"&gt;thor&lt;/a&gt;, which as we know is awesome.  To add a command to the middleman, use the following template for each &lt;code&gt;command.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman-core/cli&amp;#39;

module Middleman
  module Cli
    # This class provides a &amp;quot;deploy&amp;quot; command for the middleman CLI.
    class Graphviz &amp;lt; Thor
      include Thor::Actions

      check_unknown_options!

      namespace :graphviz

      # Tell Thor to exit with a nonzero exit code on failure
      def self.exit_on_failure?
        true
      end

      desc &amp;#39;graphviz [options]&amp;#39;, &amp;#39;Run this amazing command&amp;#39;
      method_option &amp;#39;clean&amp;#39;,
        type: :boolean,
        aliases: &amp;#39;-c&amp;#39;,
        desc: &amp;#39;Clean all the build files&amp;#39;
      def graphviz
        @shared_instance = ::Middleman::Application.server.inst

        puts &amp;quot;Running my command&amp;quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, inside of &lt;code&gt;middleman/graphviz.rb&lt;/code&gt; simply &lt;code&gt;require &amp;#39;middleman/graphviz/command&amp;#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href="http://www.rubydoc.info/github/wycats/thor/Thor/Actions"&gt;&lt;code&gt;Thor::Actions&lt;/code&gt;&lt;/a&gt; class gives you access to many different helper commands that make it easy to move, filter, template, and otherwise mangle files, and of course you have access to the full middleman app.&lt;/p&gt;

&lt;h2 id="manipulating-the-sitemap"&gt;Manipulating the sitemap&lt;/h2&gt;

&lt;p&gt;The most awesomest way to extend middleman is by modifying the sitemap.  This lets us create whole new URLs that are derived and generated from other sources.  This is how the &lt;a href="https://github.com/middleman/middleman-blog"&gt;middleman-blog&lt;/a&gt; extension really works, and if you want to start an indepth exploration that&amp;#39;s a good place to start spelunking.&lt;/p&gt;

&lt;p&gt;Lets build an extesion that creates pages from an external datasource.  In this case, a CSV file, but you could imagine having this come out of a database instead.  This lets us manipulate the sitemap of the site it&amp;#39;s been created, and will let us add and remove different pages based upon what middleman knows about the site.&lt;/p&gt;

&lt;p&gt;First we add an &lt;code&gt;after_configuration&lt;/code&gt; handler to &lt;code&gt;Middleman::Graphviz::Extension&lt;/code&gt; to register our class as a &lt;code&gt;resource_list_manipulator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def after_configuration
    @csv_pages = Middleman::CSV::Page.new( @app, self )
    @app.sitemap.register_resource_list_manipulator(:&amp;quot;csv_pages&amp;quot;, @csv_pages, false)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we create &lt;code&gt;lib/middleman/csv/page.rb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;csv&amp;#39;

module Middleman
  module CSV
    class Page
      # include UriTemplates

      def initialize(app, controller)
        @sitemap = app.sitemap
        @page_link_template = &amp;quot;pages/{page}.html&amp;quot;
        @page_template = &amp;quot;page.html&amp;quot;
        app.ignore @page_template
      end

      # Update the main sitemap resource list
      # @return [void]
      def manipulate_resource_list(resources)
        resources + ::CSV.open( &amp;quot;pages.csv&amp;quot; ).collect do |row|
          create_page_resource( row[0], row )
        end
      end

      private

      def link(page)
        ::Middleman::Util.normalize_path @page_link_template.gsub( /\{page\}/, page )
      end

      def create_page_resource( page, row )
        Sitemap::Resource.new(@sitemap, link(page)).tap do |p|
          p.proxy_to( @page_template )

          p.add_metadata locals: {
            row: row
          }
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;initialized&lt;/code&gt; is called, we are grabbing references to the middleman app.  We&amp;#39;ve hard coded two things in this example that should be from the options, the page name template, and the page template itself.  Since the &lt;code&gt;page.html&lt;/code&gt; isn&amp;#39;t meant to be standalone, we tell middleman to ignore it in the sitemap with &lt;code&gt;app.ignore @page_template&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;manipulate_resource_list&lt;/code&gt; is called it is passed a list of resources that middleman currently knows about.  We return a new list of resources based on that list.  What we are doing in this example is loading up the list of pages from a file called &lt;code&gt;pages.csv&lt;/code&gt;, creating new pages based on that, and then returning the new list.&lt;/p&gt;

&lt;p&gt;This example is contrived and we are loading in the list of pages from the filesystem.  At this point in the rendering process we do have access to all of the pages, instead of loading up a file you could inspect the site map, go through all of the pages and make additional pages for subsets of those.  The &lt;code&gt;middleman-blog&lt;/code&gt; does this for both &lt;code&gt;tag&lt;/code&gt; pages and &lt;code&gt;calendar&lt;/code&gt; pages.  Instead of calling &lt;code&gt;::CSV.open&lt;/code&gt; it goes through all of the pages on the site and collects a dynamic list of pages based upon the metatag, either &lt;code&gt;tag&lt;/code&gt; or published dates.&lt;/p&gt;

&lt;p&gt;Then we create the entries in the sitemap themselves. These first get proxied to our page template.  Then we set the metadata of the particular page to be what we loaded in from the file.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s an example template &lt;code&gt;page.html.haml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;%h1= row[1]
= row[0] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is equivelent to looping over a file in &lt;code&gt;config.rb&lt;/code&gt; and setting up page proxies there.  However in that case we don&amp;#39;t have access to the sitemap overall, so we couldn&amp;#39;t generate a dynamic list of new pages based upon existing pages.  With this extension we can insert ourselves into the rendering process and add the &lt;em&gt;awesome&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Building these extensions is a very complicated way to achive things that would be simplier if you just build the site in rails and had a database with you at runtime.  But it works, and you can achieve plug into the rendering process to create a more &lt;em&gt;dynamic&lt;/em&gt; static site.  Helpers are by far the easiest way to package things together, and as you can see from the example I&amp;#39;m working through I&amp;#39;m working on an easy way to integrate Graphviz images in middleman documents without a seperate workflow.  (&lt;em&gt;Coming soon.&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Middleman CLI commands are also easy to build, though here you do start to need to know more about how the internals of how middleman is setup.  Things like the &lt;code&gt;middleman-deploy&lt;/code&gt; gem are pretty amazing and can really help with the overall publishing workflow.&lt;/p&gt;

&lt;p&gt;And sitemap manipulation is the most powerful, which lets you recreate pages based upon site and page metadata that is collected throughout the process.  The entire &lt;code&gt;middleman-blog&lt;/code&gt; extention is build using this functionality.&lt;/p&gt;

&lt;p&gt;Happy building!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Middleman Tricks and Hacks</title>
    <link rel="alternate" href="http://willschenk.com/middleman-tricks-and-hacks/"/>
    <id>http://willschenk.com/middleman-tricks-and-hacks/</id>
    <published>2014-12-12T19:00:00-05:00</published>
    <updated>2014-12-12T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;As part of the process of getting this site to work, I learned some more things about how to better build a site with middleman.  Building off of our &lt;a href="/building-sites-with-middleman/"&gt;foundational article&lt;/a&gt; here are a few other things that I found very useful when using middleman to build a static site with a bunch of dynamically generated content.&lt;/p&gt;

&lt;h2 id="partials"&gt;Partials&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;index.html.haml&lt;/code&gt;, &lt;code&gt;articles.html.haml&lt;/code&gt;, &lt;code&gt;tag.html.haml&lt;/code&gt; and &lt;code&gt;calendar.html.haml&lt;/code&gt; pages all use the same partial to list out the post archives, which are mostly the same.&lt;/p&gt;

&lt;p&gt;On the &lt;em&gt;index&lt;/em&gt; page it&amp;#39;s called like this, where I&amp;#39;m supressing the date heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;= partial &amp;quot;post_list&amp;quot;, :locals =&amp;gt; {:page_articles =&amp;gt; blog.articles[1..4], :no_date =&amp;gt; true }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the &lt;em&gt;articles&lt;/em&gt; I&amp;#39;m including draft posts for my own reference, and since they don&amp;#39;t have a published date we need to check for that.&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;= partial &amp;quot;post_list&amp;quot;, :locals =&amp;gt; {:page_articles =&amp;gt; (drafts + page_articles)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;_post_list.haml&lt;/code&gt; file then has some logic to show date headings based upon the published dates of the articles.  (This assumes that the posts are sorted by time, either ascending or descending.) &lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;- last_date = nil
- no_date = !!no_date
%ul
  - page_articles.each do |current_post|
    - if !no_date &amp;amp;&amp;amp; current_post.date
      - date_string = current_post.date.strftime(&amp;#39;%b %Y&amp;#39;)
      - if last_date != date_string
        %li.date
          %h2= date_string
      - last_date = date_string
    %li
      .more
        - unless current_post.is_a? ::Middleman::Blog::Drafts::DraftArticle
          = current_post.date.strftime( &amp;#39;%b %e&amp;#39; )
        - else
          Draft
      %div= link_to current_post.title, current_post
      %div
        = current_post.data[&amp;#39;subtitle&amp;#39;]

        .tags
          - current_post.tags.sort.each do |tag|
            .tag= link_to tag, tag_path( tag )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Partials also work better when using &lt;a href="/bootstrap-advanced-grid-tricks/"&gt;semantic CSS classes&lt;/a&gt; to define my layouts, since the same class can have different meaning depending upon what it is embedded in.&lt;/p&gt;

&lt;h2 id="layouts-and-partials-for-articles"&gt;Layouts and partials for articles&lt;/h2&gt;

&lt;p&gt;Middleman posts are generally written in markdown, which translates into a series of &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags that are dumped into a layout file.  In order to create the table of contents on the left, the navigation to other articles on the right, the unique header and footer, I used a seperate &lt;code&gt;article_layout&lt;/code&gt; for article pages.  Setting up &lt;strong&gt;Scrollspy&lt;/strong&gt; and &lt;strong&gt;Affix&lt;/strong&gt; means we need to change things on the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag that we don&amp;#39;t need to do for other pages, so it makes more sense to use a seperate file here rather than a &lt;em&gt;nested layout&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This means that all the things that are shared between the two layouts, the main layout for all the meta pages and the article layout for the content pages, should be factored into partials.  I put these partials in the &lt;code&gt;layouts/&lt;/code&gt; directory.&lt;/p&gt;

&lt;h2 id="communication-between-partials"&gt;Communication between partials&lt;/h2&gt;

&lt;p&gt;The top and the bottom of these pages change together.  If the page has a header image -- something I specify in the YAML preamble of my post -- then both the &lt;code&gt;article_header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; partials display slightly different things.  The logic for this check is in the &lt;code&gt;article_header&lt;/code&gt;, where I set a &lt;em&gt;instance variable&lt;/em&gt; that I use in a later partial to add a class.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;layouts/_article_header.haml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- @lighter ||= &amp;quot;&amp;quot;
- @dark_header = &amp;quot;dark_header&amp;quot; if current_article.data[&amp;#39;dark_header&amp;#39;]
- if !current_article.data[&amp;#39;header_image&amp;#39;].nil? &amp;amp;&amp;amp; current_article.data[&amp;#39;header_image&amp;#39;] != &amp;quot;&amp;quot;
  - @lighter = &amp;quot;lighter&amp;quot;
  .banner
    = image_tag current_article.data[&amp;#39;header_image&amp;#39;], class: &amp;quot;fadeInDown animated&amp;quot;

%div{ class: &amp;quot;article-header #{@lighter} #{@dark_header}&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then in &lt;code&gt;layouts/_footer.haml&lt;/code&gt; I use the same variable to add a class to the &lt;code&gt;footer&lt;/code&gt; element which changes the background.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%footer{ class: &amp;quot;footer #{@lighter} #{@dark_header}&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="markdown-with-toc-data"&gt;Markdown with toc data&lt;/h2&gt;

&lt;p&gt;Inside of &lt;code&gt;config.rb&lt;/code&gt; we can add some better markdown processing options.  I switched to redcarpet and enabled &lt;code&gt;with_toc_data&lt;/code&gt;.  This generates id tags on the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; etc elements that we can use as anchors.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;set :markdown, :tables =&amp;gt; true, :autolink =&amp;gt; true, :gh_blockcode =&amp;gt; true, :fenced_code_blocks =&amp;gt; true, with_toc_data: true
set :markdown_engine, :redcarpet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These ids are generated by sanitizing the text between the tags, but &lt;code&gt;redcarpet&lt;/code&gt; only makes things lowercase and changes spaces to underscores, and unfortunately it doesn&amp;#39;t strip out punctuation characters and will result in ids that aren&amp;#39;t valid.  So I had to change my headers, at least until I can take a look at the redcarpet code in more detail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; This looks like it&amp;#39;s fixed in the latest git version of redcarpet, but it hasn&amp;#39;t been released as a gem yet.&lt;/p&gt;

&lt;h2 id="helpers-that-parse-the-source-file"&gt;Helpers that parse the source file&lt;/h2&gt;

&lt;p&gt;Now that we have the anchors in there, we need to generate the links to those anchors.  This can be done by parsing the source file on the article page with a helper.  It&amp;#39;s a poor man&amp;#39;s markdown processor, but it does the job.  This code lives in &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;helpers do
  def chapters( post )
    File.readlines( post.source_file ).collect do |x|
      if x =~ /^##\s(.*)/
        $1
      else
        nil
      end
    end.select { |x| x }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can then use it to generate the list of links:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;%ul.nav.toc
  %li= link_to current_article.title, &amp;quot;#top&amp;quot;
  - chapters( current_article ).each do |chapter|
    %li= link_to chapter, &amp;quot;##{chapter.downcase.gsub( /\s/, &amp;quot;-&amp;quot; )}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="helper-methods-to-do-query-ish-things"&gt;Helper methods to do query-ish things&lt;/h2&gt;

&lt;p&gt;The logic to calculate the &lt;em&gt;next&lt;/em&gt; and &lt;em&gt;previous&lt;/em&gt; articles in the series work using the tag system, and it cycles though all of the tags of the current article to find articles with corresponding tags.  Rather than showing the same article for multiple tags, I wanted to group the tags together if they all pointed to the same article.&lt;/p&gt;

&lt;p&gt;This is the type of logic that would normally be in a rails Model.  Either you&amp;#39;d do it directly out of the database, or you would process the results somehow and return something that was easy to iterate over in the view.&lt;/p&gt;

&lt;p&gt;Moving this code into helper method isolated all of that logic out of the views themselves.&lt;/p&gt;

&lt;h2 id="site-data-as-database"&gt;Site data as database&lt;/h2&gt;

&lt;p&gt;The other thing I wanted to do was to associate additional data with specific tags.  If this was an article, you could put it in the preamble, but since tags are generated dynamically from the article files we need to put them somewhere else.  That place is &lt;code&gt;data/topics.yml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="yml"&gt;---
:howto:
  :title: Howtos
  :desc: In which we go through step by step to achieve a particular goal.
:overview:
  :title: Overviews
  :desc: In which we cover a topic in depth to orient ourselves with the technology.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is referenced in views like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;- data[&amp;#39;topics&amp;#39;].each do |k,d|
  .track
    %h2= link_to d[:title], &amp;quot;/tags/#{k}.html&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This data is also referenced in the tag page as well as the main header.  It&amp;#39;s only stored in one place, which is nice and DRY.  If it got any more complicated than this, where we wanted to filter or sort it in some dynamic way then we implement that code in a helper so it could be shared across the site.&lt;/p&gt;

&lt;h2 id="directory-index-and-url_for"&gt;Directory index and url_for&lt;/h2&gt;

&lt;p&gt;To make pretty urls work in the blog, you need to have &lt;code&gt;activate :directory_indexes&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; &lt;code&gt;activate :blog&lt;/code&gt; in your &lt;code&gt;config.rb&lt;/code&gt; file.  &lt;em&gt;The order of middleman extensions in the config file matter.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The plugin works by changing the way that the &lt;code&gt;link_to&lt;/code&gt; helper works.  If you have a link that&amp;#39;s generated in another way, you should use the &lt;code&gt;url_for&lt;/code&gt; method to make sure that it get&amp;#39;s rewritten.  For example&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;= navbar_item d[&amp;#39;title&amp;#39;], url_for( &amp;quot;/tags/#{topic}.html&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="not-a-lot-of-tradeoffs"&gt;Not a lot of tradeoffs&lt;/h2&gt;

&lt;p&gt;Other than the one issue with redcarpet where I couldn&amp;#39;t control the way that the ids were being generated, there hasn&amp;#39;t been much that I haven&amp;#39;t be able to achieve with a statically generated site.  The implementation is different, but overall most of the time was spent fiddling with the CSS rather than fighting the build system.&lt;/p&gt;

&lt;p&gt;Which is how it should be.&lt;/p&gt;
</content>
  </entry>
</feed>
