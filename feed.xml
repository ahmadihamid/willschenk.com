<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blank Page Tech</title>
  <subtitle>Lets build things</subtitle>
  <id>http://willschenk.com/</id>
  <link href="http://willschenk.com/"/>
  <link href="http://willschenk.com/feed.xml" rel="self"/>
  <updated>2014-12-17T06:49:38-05:00</updated>
  <author>
    <name>Will Schenk</name>
  </author>
  <entry>
    <title>Building Middleman Extensions</title>
    <link rel="alternate" href="http://willschenk.com/building-middleman-extensions/"/>
    <id>http://willschenk.com/building-middleman-extensions/</id>
    <published>2014-12-16T19:00:00-05:00</published>
    <updated>2014-12-16T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Middleman extensions, like rails plugins, are packaged as gems.  There are three main ways to extend middleman.  You can add helpers, add middleman commands, or extend the sitemap generation in someway.  Lets go through those in detail.&lt;/p&gt;

&lt;h2 id="creating-the-extension"&gt;Creating the extension&lt;/h2&gt;

&lt;p&gt;Create a gem using &lt;code&gt;bundle gem _name_&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ bundle gem middleman-graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;middleman-core&lt;/code&gt; to your gem dependancies in the &lt;code&gt;.gemspec&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  spec.add_runtime_dependency     &amp;#39;middleman-core&amp;#39;, [&amp;#39;&amp;gt;= 3.0.0&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Register your extension into middleman.  Our gem will be activated in the sites &lt;code&gt;config.rb&lt;/code&gt; using &lt;code&gt;activate :graphviz&lt;/code&gt; and this is how middleman knows what to load.  &lt;code&gt;lib/middleman/graphviz.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman-core&amp;#39;
require &amp;quot;middleman/graphviz/version&amp;quot;
require &amp;quot;middleman/graphviz/extension&amp;quot;

::Middleman::Extensions.register(:graphviz, ::Middleman::Graphviz::Extension )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Replace with your gem name!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Write the code that actually plugs into middleman.  The we are going to add some helpers to the site, so let&amp;#39;s register them here.  Create &lt;code&gt;lib/middleman/graphviz/extension.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman/graphviz/helpers&amp;#39;

module Middleman
  module Graphviz
    class Extension &amp;lt; Middleman::Extension
      def initialize( app, options_hash = {}, &amp;amp;block)
        super

        app.helpers Middleman::Graphviz::Helpers
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Replace with your gem name!&lt;/em&gt;&lt;/p&gt;

&lt;h2 id="writing-helpers"&gt;Writing helpers&lt;/h2&gt;

&lt;p&gt;Lets create a basic helper method now in the file &lt;code&gt;lib/middleman/graphviz/helpers.rb&lt;/code&gt;. This is going to accept one parameter and a block. We are going to get the content of that block and then spit it back directly for now.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module Middleman
  module Graphviz
    module Helpers
      def basic_helper_example( param )
        &amp;quot;&amp;lt;h1&amp;gt;#{param}&amp;lt;/h1&amp;gt;&amp;quot;.html_safe
      end

      def block_helper_example( type, &amp;amp;block )
        if block_given?
          data = capture_html(&amp;amp;block)

          data = data.upcase

          concat_content(data.html_safe)
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These can be used like&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%%= basic_helper_example( &amp;quot;My Title&amp;quot;) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a block&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;%% block_helper( &amp;quot;My Title&amp;quot;) do %&amp;gt;
  This is going to be in upcase
&amp;lt;%% end %%&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="add-it-to-an-active-middleman-project"&gt;Add it to an active middleman project&lt;/h2&gt;

&lt;p&gt;Have bundler reference this new gem inside of an existing middleman project.  &lt;code&gt;Gemfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;quot;middleman-graphviz&amp;quot;, path: &amp;quot;../middleman-graphviz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside of the middleman project&amp;#39;s &lt;code&gt;config.rb&lt;/code&gt; activate it:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;activate :graphviz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now startup the middleman server, and use your helper in the page!  Note that, just like when you use a helper defined in &lt;code&gt;config.rb&lt;/code&gt; you need to restart &lt;code&gt;middleman server&lt;/code&gt; to see your change take effect.&lt;/p&gt;

&lt;h2 id="adding-configuration-to-your-extension"&gt;Adding configuration to your extension&lt;/h2&gt;

&lt;p&gt;If you want to include configurable options in your extension, here&amp;#39;s some skeleton code for &lt;code&gt;extension.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman/graphviz/helpers&amp;#39;

module Middleman
  module Graphviz
    cattr_accessor :options

    class Extension &amp;lt; Middleman::Extension
      def initialize( app, options_hash = {}, &amp;amp;block)
        super

        app.helpers Middleman::Graphviz::Helpers
      end

      def registered(app, options_hash = {}, &amp;amp;block)
        options = Options.new(options_hash)
        yield options if block_given?

        # Default options for the rsync method.
        options.theme ||= &amp;quot;default&amp;quot;
        options.generate_file ||= false

        ::Middleman::Graphviz.options = options

        app.helpers Middleman::Graphviz::Helpers
      end

      def after_configuration
        puts &amp;quot;After configuration&amp;quot;
      end
    end

    module Helpers
      def options
        ::Middleman::Graphviz.options
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="adding-additional-middleman-commands"&gt;Adding additional middleman commands&lt;/h2&gt;

&lt;p&gt;The middleman command is built on &lt;a href="/making-a-command-line-utility-with-gems-and-thor"&gt;thor&lt;/a&gt;, which as we know is awesome.  To add a command to the middleman, use the following template for each &lt;code&gt;command.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;middleman-core/cli&amp;#39;

module Middleman
  module Cli
    # This class provides a &amp;quot;deploy&amp;quot; command for the middleman CLI.
    class Graphviz &amp;lt; Thor
      include Thor::Actions

      check_unknown_options!

      namespace :graphviz

      # Tell Thor to exit with a nonzero exit code on failure
      def self.exit_on_failure?
        true
      end

      desc &amp;#39;graphviz [options]&amp;#39;, &amp;#39;Run this amazing command&amp;#39;
      method_option &amp;#39;clean&amp;#39;,
        type: :boolean,
        aliases: &amp;#39;-c&amp;#39;,
        desc: &amp;#39;Clean all the build files&amp;#39;
      def graphviz
        @shared_instance = ::Middleman::Application.server.inst

        puts &amp;quot;Running my command&amp;quot;
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, inside of &lt;code&gt;middleman/graphviz.rb&lt;/code&gt; simply &lt;code&gt;require &amp;#39;middleman/graphviz/command&amp;#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href="http://www.rubydoc.info/github/wycats/thor/Thor/Actions"&gt;&lt;code&gt;Thor::Actions&lt;/code&gt;&lt;/a&gt; class gives you access to many different helper commands that make it easy to move, filter, template, and otherwise mangle files, and of course you have access to the full middleman app.&lt;/p&gt;

&lt;h2 id="manipulating-the-sitemap"&gt;Manipulating the sitemap&lt;/h2&gt;

&lt;p&gt;The most awesomest way to extend middleman is by modifying the sitemap.  This lets us create whole new URLs that are derived and generated from other sources.  This is how the &lt;a href="https://github.com/middleman/middleman-blog"&gt;middleman-blog&lt;/a&gt; extension really works, and if you want to start an indepth exploration that&amp;#39;s a good place to start spelunking.&lt;/p&gt;

&lt;p&gt;Lets build an extesion that creates pages from an external datasource.  In this case, a CSV file, but you could imagine having this come out of a database instead.  This lets us manipulate the sitemap of the site it&amp;#39;s been created, and will let us add and remove different pages based upon what middleman knows about the site.&lt;/p&gt;

&lt;p&gt;First we add an &lt;code&gt;after_configuration&lt;/code&gt; handler to &lt;code&gt;Middleman::Graphviz::Extension&lt;/code&gt; to register our class as a &lt;code&gt;resource_list_manipulator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def after_configuration
    @csv_pages = Middleman::CSV::Page.new( @app, self )
    @app.sitemap.register_resource_list_manipulator(:&amp;quot;csv_pages&amp;quot;, @csv_pages, false)
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we create &lt;code&gt;lib/middleman/csv/page.rb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;csv&amp;#39;

module Middleman
  module CSV
    class Page
      # include UriTemplates

      def initialize(app, controller)
        @sitemap = app.sitemap
        @page_link_template = &amp;quot;pages/{page}.html&amp;quot;
        @page_template = &amp;quot;page.html&amp;quot;
        app.ignore @page_template
      end

      # Update the main sitemap resource list
      # @return [void]
      def manipulate_resource_list(resources)
        resources + ::CSV.open( &amp;quot;pages.csv&amp;quot; ).collect do |row|
          create_page_resource( row[0], row )
        end
      end

      private

      def link(page)
        ::Middleman::Util.normalize_path @page_link_template.gsub( /\{page\}/, page )
      end

      def create_page_resource( page, row )
        Sitemap::Resource.new(@sitemap, link(page)).tap do |p|
          p.proxy_to( @page_template )

          p.add_metadata locals: {
            row: row
          }
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;initialized&lt;/code&gt; is called, we are grabbing references to the middleman app.  We&amp;#39;ve hard coded two things in this example that should be from the options, the page name template, and the page template itself.  Since the &lt;code&gt;page.html&lt;/code&gt; isn&amp;#39;t meant to be standalone, we tell middleman to ignore it in the sitemap with &lt;code&gt;app.ignore @page_template&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;manipulate_resource_list&lt;/code&gt; is called it is passed a list of resources that middleman currently knows about.  We return a new list of resources based on that list.  What we are doing in this example is loading up the list of pages from a file called &lt;code&gt;pages.csv&lt;/code&gt;, creating new pages based on that, and then returning the new list.&lt;/p&gt;

&lt;p&gt;This example is contrived and we are loading in the list of pages from the filesystem.  At this point in the rendering process we do have access to all of the pages, instead of loading up a file you could inspect the site map, go through all of the pages and make additional pages for subsets of those.  The &lt;code&gt;middleman-blog&lt;/code&gt; does this for both &lt;code&gt;tag&lt;/code&gt; pages and &lt;code&gt;calendar&lt;/code&gt; pages.  Instead of calling &lt;code&gt;::CSV.open&lt;/code&gt; it goes through all of the pages on the site and collects a dynamic list of pages based upon the metatag, either &lt;code&gt;tag&lt;/code&gt; or published dates.&lt;/p&gt;

&lt;p&gt;Then we create the entries in the sitemap themselves. These first get proxied to our page template.  Then we set the metadata of the particular page to be what we loaded in from the file.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s an example template &lt;code&gt;page.html.haml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;%h1= row[1]
= row[0] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This example is equivelent to looping over a file in &lt;code&gt;config.rb&lt;/code&gt; and setting up page proxies there.  However in that case we don&amp;#39;t have access to the sitemap overall, so we couldn&amp;#39;t generate a dynamic list of new pages based upon existing pages.  With this extension we can insert ourselves into the rendering process and add the &lt;em&gt;awesome&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Building these extensions is a very complicated way to achive things that would be simplier if you just build the site in rails and had a database with you at runtime.  But it works, and you can achieve plug into the rendering process to create a more &lt;em&gt;dynamic&lt;/em&gt; static site.  Helpers are by far the easiest way to package things together, and as you can see from the example I&amp;#39;m working through I&amp;#39;m working on an easy way to integrate Graphviz images in middleman documents without a seperate workflow.  (&lt;em&gt;Coming soon.&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;Middleman CLI commands are also easy to build, though here you do start to need to know more about how the internals of how middleman is setup.  Things like the &lt;code&gt;middleman-deploy&lt;/code&gt; gem are pretty amazing and can really help with the overall publishing workflow.&lt;/p&gt;

&lt;p&gt;And sitemap manipulation is the most powerful, which lets you recreate pages based upon site and page metadata that is collected throughout the process.  The entire &lt;code&gt;middleman-blog&lt;/code&gt; extention is build using this functionality.&lt;/p&gt;

&lt;p&gt;Happy building!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Middleman Tricks and Hacks</title>
    <link rel="alternate" href="http://willschenk.com/middleman-tricks-and-hacks/"/>
    <id>http://willschenk.com/middleman-tricks-and-hacks/</id>
    <published>2014-12-12T19:00:00-05:00</published>
    <updated>2014-12-12T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;As part of the process of getting this site to work, I learned some more things about how to better build a site with middleman.  Building off of our &lt;a href="/building-sites-with-middleman/"&gt;foundational article&lt;/a&gt; here are a few other things that I found very useful when using middleman to build a static site with a bunch of dynamically generated content.&lt;/p&gt;

&lt;h2 id="partials"&gt;Partials&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;index.html.haml&lt;/code&gt;, &lt;code&gt;articles.html.haml&lt;/code&gt;, &lt;code&gt;tag.html.haml&lt;/code&gt; and &lt;code&gt;calendar.html.haml&lt;/code&gt; pages all use the same partial to list out the post archives, which are mostly the same.&lt;/p&gt;

&lt;p&gt;On the &lt;em&gt;index&lt;/em&gt; page it&amp;#39;s called like this, where I&amp;#39;m supressing the date heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;= partial &amp;quot;post_list&amp;quot;, :locals =&amp;gt; {:page_articles =&amp;gt; blog.articles[1..4], :no_date =&amp;gt; true }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the &lt;em&gt;articles&lt;/em&gt; I&amp;#39;m including draft posts for my own reference, and since they don&amp;#39;t have a published date we need to check for that.&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;= partial &amp;quot;post_list&amp;quot;, :locals =&amp;gt; {:page_articles =&amp;gt; (drafts + page_articles)}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;_post_list.haml&lt;/code&gt; file then has some logic to show date headings based upon the published dates of the articles.  (This assumes that the posts are sorted by time, either ascending or descending.) &lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;- last_date = nil
- no_date = !!no_date
%ul
  - page_articles.each do |current_post|
    - if !no_date &amp;amp;&amp;amp; current_post.date
      - date_string = current_post.date.strftime(&amp;#39;%b %Y&amp;#39;)
      - if last_date != date_string
        %li.date
          %h2= date_string
      - last_date = date_string
    %li
      .more
        - unless current_post.is_a? ::Middleman::Blog::Drafts::DraftArticle
          = current_post.date.strftime( &amp;#39;%b %e&amp;#39; )
        - else
          Draft
      %div= link_to current_post.title, current_post
      %div
        = current_post.data[&amp;#39;subtitle&amp;#39;]

        .tags
          - current_post.tags.sort.each do |tag|
            .tag= link_to tag, tag_path( tag )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Partials also work better when using &lt;a href="/bootstrap-advanced-grid-tricks/"&gt;semantic CSS classes&lt;/a&gt; to define my layouts, since the same class can have different meaning depending upon what it is embedded in.&lt;/p&gt;

&lt;h2 id="layouts-and-partials-for-articles"&gt;Layouts and partials for articles&lt;/h2&gt;

&lt;p&gt;Middleman posts are generally written in markdown, which translates into a series of &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags that are dumped into a layout file.  In order to create the table of contents on the left, the navigation to other articles on the right, the unique header and footer, I used a seperate &lt;code&gt;article_layout&lt;/code&gt; for article pages.  Setting up &lt;strong&gt;Scrollspy&lt;/strong&gt; and &lt;strong&gt;Affix&lt;/strong&gt; means we need to change things on the &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; tag that we don&amp;#39;t need to do for other pages, so it makes more sense to use a seperate file here rather than a &lt;em&gt;nested layout&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This means that all the things that are shared between the two layouts, the main layout for all the meta pages and the article layout for the content pages, should be factored into partials.  I put these partials in the &lt;code&gt;layouts/&lt;/code&gt; directory.&lt;/p&gt;

&lt;h2 id="communication-between-partials"&gt;Communication between partials&lt;/h2&gt;

&lt;p&gt;The top and the bottom of these pages change together.  If the page has a header image -- something I specify in the YAML preamble of my post -- then both the &lt;code&gt;article_header&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt; partials display slightly different things.  The logic for this check is in the &lt;code&gt;article_header&lt;/code&gt;, where I set a &lt;em&gt;instance variable&lt;/em&gt; that I use in a later partial to add a class.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;layouts/_article_header.haml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- @lighter ||= &amp;quot;&amp;quot;
- @dark_header = &amp;quot;dark_header&amp;quot; if current_article.data[&amp;#39;dark_header&amp;#39;]
- if !current_article.data[&amp;#39;header_image&amp;#39;].nil? &amp;amp;&amp;amp; current_article.data[&amp;#39;header_image&amp;#39;] != &amp;quot;&amp;quot;
  - @lighter = &amp;quot;lighter&amp;quot;
  .banner
    = image_tag current_article.data[&amp;#39;header_image&amp;#39;], class: &amp;quot;fadeInDown animated&amp;quot;

%div{ class: &amp;quot;article-header #{@lighter} #{@dark_header}&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then in &lt;code&gt;layouts/_footer.haml&lt;/code&gt; I use the same variable to add a class to the &lt;code&gt;footer&lt;/code&gt; element which changes the background.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%footer{ class: &amp;quot;footer #{@lighter} #{@dark_header}&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="markdown-with-toc-data"&gt;Markdown with toc data&lt;/h2&gt;

&lt;p&gt;Inside of &lt;code&gt;config.rb&lt;/code&gt; we can add some better markdown processing options.  I switched to redcarpet and enabled &lt;code&gt;with_toc_data&lt;/code&gt;.  This generates id tags on the &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; etc elements that we can use as anchors.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;set :markdown, :tables =&amp;gt; true, :autolink =&amp;gt; true, :gh_blockcode =&amp;gt; true, :fenced_code_blocks =&amp;gt; true, with_toc_data: true
set :markdown_engine, :redcarpet
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These ids are generated by sanitizing the text between the tags, but &lt;code&gt;redcarpet&lt;/code&gt; only makes things lowercase and changes spaces to underscores, and unfortunately it doesn&amp;#39;t strip out punctuation characters and will result in ids that aren&amp;#39;t valid.  So I had to change my headers, at least until I can take a look at the redcarpet code in more detail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; This looks like it&amp;#39;s fixed in the latest git version of redcarpet, but it hasn&amp;#39;t been released as a gem yet.&lt;/p&gt;

&lt;h2 id="helpers-that-parse-the-source-file"&gt;Helpers that parse the source file&lt;/h2&gt;

&lt;p&gt;Now that we have the anchors in there, we need to generate the links to those anchors.  This can be done by parsing the source file on the article page with a helper.  It&amp;#39;s a poor man&amp;#39;s markdown processor, but it does the job.  This code lives in &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;helpers do
  def chapters( post )
    File.readlines( post.source_file ).collect do |x|
      if x =~ /^##\s(.*)/
        $1
      else
        nil
      end
    end.select { |x| x }
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can then use it to generate the list of links:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;%ul.nav.toc
  %li= link_to current_article.title, &amp;quot;#top&amp;quot;
  - chapters( current_article ).each do |chapter|
    %li= link_to chapter, &amp;quot;##{chapter.downcase.gsub( /\s/, &amp;quot;-&amp;quot; )}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="helper-methods-to-do-query-ish-things"&gt;Helper methods to do query-ish things&lt;/h2&gt;

&lt;p&gt;The logic to calculate the &lt;em&gt;next&lt;/em&gt; and &lt;em&gt;previous&lt;/em&gt; articles in the series work using the tag system, and it cycles though all of the tags of the current article to find articles with corresponding tags.  Rather than showing the same article for multiple tags, I wanted to group the tags together if they all pointed to the same article.&lt;/p&gt;

&lt;p&gt;This is the type of logic that would normally be in a rails Model.  Either you&amp;#39;d do it directly out of the database, or you would process the results somehow and return something that was easy to iterate over in the view.&lt;/p&gt;

&lt;p&gt;Moving this code into helper method isolated all of that logic out of the views themselves.&lt;/p&gt;

&lt;h2 id="site-data-as-database"&gt;Site data as database&lt;/h2&gt;

&lt;p&gt;The other thing I wanted to do was to associate additional data with specific tags.  If this was an article, you could put it in the preamble, but since tags are generated dynamically from the article files we need to put them somewhere else.  That place is &lt;code&gt;data/topics.yml&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="yml"&gt;---
:howto:
  :title: Howtos
  :desc: In which we go through step by step to achieve a particular goal.
:overview:
  :title: Overviews
  :desc: In which we cover a topic in depth to orient ourselves with the technology.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is referenced in views like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;- data[&amp;#39;topics&amp;#39;].each do |k,d|
  .track
    %h2= link_to d[:title], &amp;quot;/tags/#{k}.html&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This data is also referenced in the tag page as well as the main header.  It&amp;#39;s only stored in one place, which is nice and DRY.  If it got any more complicated than this, where we wanted to filter or sort it in some dynamic way then we implement that code in a helper so it could be shared across the site.&lt;/p&gt;

&lt;h2 id="directory-index-and-url_for"&gt;Directory index and url_for&lt;/h2&gt;

&lt;p&gt;To make pretty urls work in the blog, you need to have &lt;code&gt;activate :directory_indexes&lt;/code&gt; &lt;em&gt;after&lt;/em&gt; &lt;code&gt;activate :blog&lt;/code&gt; in your &lt;code&gt;config.rb&lt;/code&gt; file.  &lt;em&gt;The order of middleman extensions in the config file matter.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The plugin works by changing the way that the &lt;code&gt;link_to&lt;/code&gt; helper works.  If you have a link that&amp;#39;s generated in another way, you should use the &lt;code&gt;url_for&lt;/code&gt; method to make sure that it get&amp;#39;s rewritten.  For example&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;= navbar_item d[&amp;#39;title&amp;#39;], url_for( &amp;quot;/tags/#{topic}.html&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="not-a-lot-of-tradeoffs"&gt;Not a lot of tradeoffs&lt;/h2&gt;

&lt;p&gt;Other than the one issue with redcarpet where I couldn&amp;#39;t control the way that the ids were being generated, there hasn&amp;#39;t been much that I haven&amp;#39;t be able to achieve with a statically generated site.  The implementation is different, but overall most of the time was spent fiddling with the CSS rather than fighting the build system.&lt;/p&gt;

&lt;p&gt;Which is how it should be.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Dateslice: Writing rails extensions</title>
    <link rel="alternate" href="http://willschenk.com/dateslice-writing-rails-extensions/"/>
    <id>http://willschenk.com/dateslice-writing-rails-extensions/</id>
    <published>2014-12-06T19:00:00-05:00</published>
    <updated>2014-12-06T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;Ruby on Rails is a very modular framework since the merging with Merb in 2008.  The &lt;em&gt;opinionated conventions&lt;/em&gt; are implemented under using techniques that let you jump in and build your own components, picking and choosing different parts that let you build Rails apps in the same straightforward way you would if using the official modules.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s go through the &lt;a href="https://github.com/HappyFunCorp/dateslices"&gt;&lt;code&gt;dateslices&lt;/code&gt; gem&lt;/a&gt; which I wrote to extend active record so that we could better interact with the &lt;code&gt;group by&lt;/code&gt; sql command when dealing with dates.  Thanks to &lt;a href="https://github.com/mbrookes"&gt;mbrookes&lt;/a&gt; this command now outputs in a format compatible with &lt;a href="http://ankane.github.io/chartkick/"&gt;Chartkick&lt;/a&gt; making it a good tool to use when graphing date related things, say user signups, on an admin panel for your application.&lt;/p&gt;

&lt;h2 id="databases"&gt;Databases&lt;/h2&gt;

&lt;p&gt;&lt;a href="http://guides.rubyonrails.org/active_record_basics.html"&gt;ActiveRecord&lt;/a&gt; is how Rails interacts with the database, this includes both SQL generation, validations, and a whole bunch more.  It creates a startardized interface over the many subtle differences between SQL implementations on different databases.  Date handling and grouping on dymanic terms is one area where databases differer greatly from one another, and when we want to find counts and sums grouped by different dates we need to tune our SQL for the vagaries of switching to different databases.&lt;/p&gt;

&lt;h2 id="keeping-development-the-same-as-production"&gt;Keeping development the same as production&lt;/h2&gt;

&lt;p&gt;I tend to develop locally on Sqlite3 and deploy on Postgres.  When we get into something fancy where we want to use some of the amazing features that Postgres has, like &lt;a href="http://www.postgresql.org/docs/9.2/static/libpq-notify.html"&gt;LISTEN/NOTIFY&lt;/a&gt; or &lt;a href="http://postgresguide.com/sexy/hstore.html"&gt;hstore&lt;/a&gt; , then it makes sense to run a Postgres instance locally.  But most of the time it&amp;#39;s overkill, and I prefer running with Sqlite3 since I just need to checkout the project, run bundle, and I&amp;#39;m in a self contained environment.&lt;/p&gt;

&lt;p&gt;Pub/sub and attribute store are cool enough things to warrant managing a local Postgres instance, grouping by date doesn&amp;#39;t cut it in my book.&lt;/p&gt;

&lt;p&gt;If you do already have a Postgres instance running locally, then you should check out the &lt;a href="https://github.com/ankane/groupdate"&gt;&lt;code&gt;groupdate&lt;/code&gt; gem&lt;/a&gt;, which is better and worse than &lt;code&gt;dateslice&lt;/code&gt;: better because it supports Timezones which is awesome and difficult to solve well and worse because it doesn&amp;#39;t support Sqlite3.&lt;/p&gt;

&lt;h2 id="enter-dataslice"&gt;Enter dataslice&lt;/h2&gt;

&lt;p&gt;Lets first take a look at how the SQL differs between the different databases.  The basic structure is&lt;/p&gt;

&lt;pre&gt;&lt;code class="sql"&gt;select aggregation(aggregation_column), timeslice from table group by timeslice
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where &lt;code&gt;aggregation&lt;/code&gt; is one of &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, and &lt;code&gt;avg&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aggregation_column&lt;/code&gt; is the column we are counting, summing or averaging.  For counts, normally we do &lt;code&gt;count(*)&lt;/code&gt; but we can also do &lt;code&gt;count(distinct(aggregation_column))&lt;/code&gt; if you only want to count the number of unique occurances.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;timeslice&lt;/code&gt; is the time period that we want to look at.  The basic idea here is that we convert a &lt;code&gt;datetime&lt;/code&gt; to a string with lower precision (getting rid of the seconds, or minutes, or hours, or days) and then group on that string.  We need to select this on the left side of the query, and we also need it as the input of the &lt;code&gt;GROUP BY&lt;/code&gt; on the right.&lt;/p&gt;

&lt;p&gt;For example, if we want to group by day, this is the SQL that we&amp;#39;d need for the 3 different database variants we are targetting:&lt;/p&gt;

&lt;table class="table table-bordered"&gt;
  &lt;tr&gt;&lt;th&gt;Database&lt;/th&gt;&lt;th&gt;Time Slice&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Mysql&lt;/th&gt;&lt;td&gt;&lt;code&gt;DATE_FORMAT(#{column}, '%Y-%m-%d 00:00:00 UTC')&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Sqlite3&lt;/th&gt;&lt;td&gt;&lt;code&gt;strftime( \"%Y-%m-%d 00:00:00 UTC\", #{column} )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Postgres&lt;/th&gt;&lt;td&gt;&lt;code&gt;DATE_TRUNC( 'day' , #{column} )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;The different variants can be found in the sourecode for &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/mysql.rb"&gt;mysql&lt;/a&gt;, &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/sqlite.rb"&gt;sqlite&lt;/a&gt;, and &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/postgresql.rb"&gt;Postgres&lt;/a&gt;.  (Notice how Postgres is better here too!)&lt;/p&gt;

&lt;h2 id="our-api"&gt;Our api&lt;/h2&gt;

&lt;p&gt;We want to add &lt;code&gt;group_by_second&lt;/code&gt;, &lt;code&gt;group_by_minute&lt;/code&gt;, &lt;code&gt;group_by_hour&lt;/code&gt;, &lt;code&gt;group_by_day&lt;/code&gt;, &lt;code&gt;group_by_week&lt;/code&gt;, &lt;code&gt;group_by_day_of_week&lt;/code&gt;, &lt;code&gt;group_by_month&lt;/code&gt;, &lt;code&gt;group_by_year&lt;/code&gt; to ActiveRecord classes that we can use either on the model itself:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;User.group_by_day
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or on a scope:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;Post.unmoderated.group_by_day
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And get a resulting hash back like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;{
      &amp;quot;2014-07-12 00:00:00 UTC&amp;quot; =&amp;gt; 1,
      &amp;quot;2014-07-18 00:00:00 UTC&amp;quot; =&amp;gt; 2,
      &amp;quot;2014-07-19 00:00:00 UTC&amp;quot; =&amp;gt; 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in a &lt;code&gt;rspec&lt;/code&gt; test, something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  it &amp;quot;should return items grouped by day&amp;quot; do
    expect( User.count ).to eq(0)

    @initial_time = Time.parse &amp;quot;2014-07-19 15:26:48 -0400&amp;quot;

    User.create created_at: @initial_time
    User.create created_at: @initial_time - 1.day
    User.create created_at: @initial_time - 1.day
    User.create created_at: @initial_time - 1.week

    expect( User.count ).to eq( 4 )

    res = User.group_by_day( :created_at )

    expect(res).to eq({
      &amp;quot;2014-07-12 00:00:00 UTC&amp;quot; =&amp;gt; 1,
      &amp;quot;2014-07-18 00:00:00 UTC&amp;quot; =&amp;gt; 2,
      &amp;quot;2014-07-19 00:00:00 UTC&amp;quot; =&amp;gt; 1})
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="building-the-rails-extension"&gt;Building the Rails Extension&lt;/h2&gt;

&lt;p&gt;Now that we have an idea of what we want to generate, lets take a look at how we build a rails extension.  This is done with the &lt;code&gt;rails plugin new&lt;/code&gt; command.  We saw the &lt;code&gt;bundle gem&lt;/code&gt; command before back in the &lt;a href="/making-a-command-line-utility-with-gems-and-thor/"&gt;making a command line utility with gems and thor&lt;/a&gt; post, and in many ways they are similar.  But the &lt;code&gt;rails plugin new&lt;/code&gt; command creates a gem setup for a rails environment for testing and developing your app.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/"&gt;Happy Seed&lt;/a&gt; also has a rails plugin generator which will setup rspec testing for you, instead of the default &lt;code&gt;TestUnit&lt;/code&gt;.  This runs the &lt;code&gt;rails plugin new&lt;/code&gt; command which sets up the rails gem environment and does a few other things you need to do to get rspec working correctly, and HappySeed will do that stuff for you.&lt;/p&gt;

&lt;p&gt;Either way, now you have a new folder with an empty gem that we need to fill out.&lt;/p&gt;

&lt;p&gt;We&amp;#39;re going to create a &lt;code&gt;Module&lt;/code&gt;,  &lt;code&gt;Datelices::Scope&lt;/code&gt;, with our methods and then register our methods with the &lt;code&gt;ActiveRecord::Base&lt;/code&gt; class.  This looks like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt; ActiveRecord::Base.send(:extend, Dateslices::Scopes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will mixin our methods into all of the classes that extend &lt;code&gt;ActiveRecord::Base&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="metaprogramming-with-ruby"&gt;Metaprogramming with Ruby&lt;/h2&gt;

&lt;p&gt;Inside of &lt;code&gt;lib/dateslices.rb&lt;/code&gt; lets define all of the fields that we want to define.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module Dateslices
  FIELDS = [:second, :minute, :hour, :day, :week, :day_of_week, :month, :year ]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now inside of &lt;code&gt;lib/dateslices/scopes.rb&lt;/code&gt; we can sketch out our scopes method generator:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;module Dateslices
  module Scopes
    Dateslices::FIELDS.each do |field|
      define_method :&amp;quot;group_by_#{field}&amp;quot; do |*args|
        # create query based on args, and field
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets go through this for a second.  When this code is evaluated, we are going to loop over &lt;code&gt;Dateslices::FIELDS&lt;/code&gt; and call the &lt;code&gt;define_method&lt;/code&gt; function for each type of grouping.  These are defined inside of the main &lt;code&gt;Dateslices&lt;/code&gt; module, and we are naming our method &lt;code&gt;:&amp;quot;group_by_#{field}&amp;quot;&lt;/code&gt;.  Image that a developer writes &lt;code&gt;User.group_by_day( :updated_at )&lt;/code&gt;, what happens then?&lt;/p&gt;

&lt;p&gt;When that is invoked the Ruby runtime is actually invoking the closure that we are passing into &lt;code&gt;define_method&lt;/code&gt;, which is generated inside of the loop with a different value for &lt;code&gt;field&lt;/code&gt; on each one.  In addition to using this inside of the name of the function, this value is available inside of the body.  The &lt;code&gt;*args&lt;/code&gt; on the other hand, and in our example it would equal &lt;code&gt;[:updated_at]&lt;/code&gt;, comes from the method invocation as we would expect.&lt;/p&gt;

&lt;p&gt;We are writing code which generates code, and some of the variables are part of our desire &amp;quot;not to write 15 of the basically the same methods&amp;quot; and some of the variables are there to tweak the functionality of the API.&lt;/p&gt;

&lt;h2 id="the-sql-bit"&gt;The SQL Bit&lt;/h2&gt;

&lt;p&gt;The full details can be found in &lt;a href="https://github.com/HappyFunCorp/dateslices/blob/master/lib/dateslices/scopes.rb"&gt;the repo&lt;/a&gt; but here&amp;#39;s the bit that actually generates the query switching out to the various classes that know how to deal with each of the databases that we saw before.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;args = args.dup

column = args[0].blank? ? &amp;#39;created_at&amp;#39; : args[0]
aggregation = args[1].blank? ? &amp;#39;count&amp;#39; : args[1]
aggregation_column = args[2].blank? ? &amp;#39;*&amp;#39; : args[2]

sql = [&amp;quot;#{aggregation}(#{aggregation_column}) as count&amp;quot;]

time_filter = case connection.adapter_name
                when &amp;#39;SQLite&amp;#39;
                  Dateslices::Sqlite.time_filter(column, field)
                when &amp;#39;PostgreSQL&amp;#39;, &amp;#39;PostGIS&amp;#39;
                  Dateslices::Postgresql.time_filter(column, field)
                when &amp;#39;MySQL&amp;#39;, &amp;#39;Mysql2&amp;#39;
                  Dateslices::Mysql.time_filter(column, field)
                else
                  throw &amp;quot;Unknown database adaptor #{connection.adapter_name}&amp;quot;
              end

sql &amp;lt;&amp;lt; &amp;quot;#{time_filter} as date_slice&amp;quot;

slices = select( sql.join(&amp;#39;, &amp;#39;)).where.not(column =&amp;gt; nil).group(&amp;#39;date_slice&amp;#39;).order(&amp;#39;date_slice&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full code does a bit more to figure out how you want to see the data, but that&amp;#39;s the tricky stuff.&lt;/p&gt;

&lt;h2 id="testing-a-rails-plugin-that-talks-to-many-databases"&gt;Testing a rails plugin that talks to many databases&lt;/h2&gt;

&lt;p&gt;The first thing that&amp;#39;s a little strange when testing a plugin is that you can test your gem in two different contexts: one in a basic ruby context, and your tests go into &lt;code&gt;spec/&lt;/code&gt;, and the other in a rails context.  The plugin generator will create a sample rails app inside of &lt;code&gt;spec/dummy&lt;/code&gt; (or &lt;code&gt;test/dummy&lt;/code&gt; if you are using &lt;code&gt;rails plugin new&lt;/code&gt; without our fancy rspec stuff).  &lt;/p&gt;

&lt;p&gt;Let&amp;#39;s take a look now at how to test a gem that talks to many different databases.  Normally when we start up a rails environment, test or otherwise, it connects to a database and that&amp;#39;s that.  However, we need to run the same test suite over 3 different databases making sure that the gem behaves in exactly the same way for each one.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s our &lt;code&gt;spec/dummy/spec/models/test_spec.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;require &amp;#39;rails_helper&amp;#39;
require &amp;#39;dateslice_tester&amp;#39;
require &amp;#39;groupdate_tester&amp;#39;

databases = [{ :adapter =&amp;gt; &amp;#39;mysql&amp;#39;, :database =&amp;gt; &amp;#39;dateslice_test&amp;#39;, :user =&amp;gt; &amp;#39;root&amp;#39;},
             { :adapter =&amp;gt; &amp;#39;postgresql&amp;#39;, :database =&amp;gt; &amp;#39;dateslice_test&amp;#39;},
             { :adapter =&amp;gt; &amp;#39;sqlite3&amp;#39;, :database =&amp;gt; &amp;#39;db/test.sqlite3&amp;#39;}]

formats = [&amp;#39;groupdate&amp;#39;, &amp;#39;dateslice&amp;#39;]

databases.each do |database|
  formats.each do |format|
    RSpec.describe &amp;quot;#{database[:adapter].titleize} #{format}&amp;quot;, :type =&amp;gt; :model do
      include_examples format, database
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This code was based on something I cobbled together but cleaned up by &lt;a href="https://github.com/mbrookes"&gt;mbrookes&lt;/a&gt;, thanks mbrooks!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We first define a set a database configuration for our test databases.  We then loop over that, and use the &lt;code&gt;include_examples&lt;/code&gt; feature of &lt;code&gt;RSpec&lt;/code&gt;, passing in the both the output format and the database configuration that we want to test.  We have two files of examples, one which defines the &lt;code&gt;groupdate&lt;/code&gt; format, and the other which defines the &lt;code&gt;dateslices&lt;/code&gt; format.  Once again I&amp;#39;d like to point out that if you don&amp;#39;t care about SQLite3 support and want Timezone support, the &lt;a href="https://github.com/ankane/groupdate"&gt;groupdate&lt;/a&gt; is what you want.&lt;/p&gt;

&lt;p&gt;Lets look at the opening stanzas of &lt;code&gt;spec/dummy/spec/dateslice_tester.rb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;RSpec.shared_examples &amp;quot;dateslice&amp;quot; do |config|
  before :context do
    puts &amp;quot;Setting up #{config}&amp;quot;

    ActiveRecord::Base.establish_connection config

    puts &amp;quot;Trying to migrate&amp;quot;
    ActiveRecord::Migration.create_table :users, :force =&amp;gt; true do |t|
      t.string :name
      t.integer :score
      t.timestamp :created_at
      t.timestamp :updated_at
    end
  end

  before do
    Dateslices.output_format = :dateslice
    User.delete_all
  end

  it &amp;quot;should return items grouped by day&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RSpec.shared_examples&lt;/code&gt; is the counter part to the &lt;code&gt;include&lt;/code&gt; examples above, and when it gets called the database &lt;code&gt;config&lt;/code&gt; is passed in.  We then call  &lt;code&gt;ActiveRecord::Base.establish_connection config&lt;/code&gt; to connect &lt;code&gt;ActiveRecord&lt;/code&gt; to the database as part of the &lt;code&gt;before :context&lt;/code&gt; part of the RSpec life cycle.&lt;/p&gt;

&lt;p&gt;Next we need to actually create the database tables that we are going to run tests over.  Since we are switching the databases as part of the testing process itself, it makes no sense to use &lt;code&gt;rake db:create:test&lt;/code&gt; to create the DDL, since which database would that be creating?  We need to do 3 different ones, and we certainly don&amp;#39;t want to have an elaborate process to start any of the tests if you decide to add an additional migration.  So we call a migration directly from the code, turning &lt;code&gt;:force =&amp;gt; true&lt;/code&gt; so even if it already exists we push the current definition there.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;ActiveRecord::Migration.create_table :users, :force =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then in the regular &lt;code&gt;before&lt;/code&gt; callback we make sure that the tables are cleared our ready for the next test.&lt;/p&gt;

&lt;h2 id="just-a-bit-of-activerecord"&gt;Just a bit of ActiveRecord&lt;/h2&gt;

&lt;p&gt;We&amp;#39;ve just gone through an ActiveRecord extention and that barely scratches the surface of what else you can do with Rails.  &lt;a href="https://pragprog.com/book/jvrails2/crafting-rails-4-applications"&gt;Crafting Rails 4 Applications&lt;/a&gt; is the best resource I&amp;#39;ve found to get a sense of what is possible, but when I sat down to work on something there was a lot of trial and error.  They through how they created &lt;a href="https://github.com/plataformatec/mail_form"&gt;mail_form&lt;/a&gt;, or at least a simplified version of it, that lets you use rails validations from ActiveRecord without having to back up the model with a database.  (As you might infer from the name, something that is useful for Contact forms that send out email.)  The book also goes through how Rails Engines work, which are very much like rails plugins but with additional integration points into the rails application lifecycle.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Pulling data out of Google Analytics</title>
    <link rel="alternate" href="http://willschenk.com/pulling-data-out-of-google-analytics/"/>
    <id>http://willschenk.com/pulling-data-out-of-google-analytics/</id>
    <published>2014-12-03T19:00:00-05:00</published>
    <updated>2014-12-03T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;I like staring at the real time stats of &lt;a href="http://www.google.com/analytics/"&gt;Google Analytics&lt;/a&gt;.  As a dashboard, it&amp;#39;s not really as amazing as &lt;a href="https://chartbeat.com"&gt;Chartbeat&lt;/a&gt; is, and it doesn&amp;#39;t let you drill down into the data as much as &lt;a href="https://mixpanel.com"&gt;Mixpanel&lt;/a&gt;.  But GA is super simple to setup and it&amp;#39;s Google, so everyone uses it.&lt;/p&gt;

&lt;p&gt;Another obsessive/fun thing to do is to see where that spike in inbound traffic is coming from.  On &lt;a href="http://happyfuncorp.com"&gt;HappyFunCorp&lt;/a&gt; there are days where we get a sudden influx of &lt;a href="http://happyfuncorp.com/#happy-thoughts"&gt;Happy Thoughts&lt;/a&gt; which warms our hearts and floods our inboxes.  Where did they come from?  How do we figure it out?&lt;/p&gt;

&lt;p&gt;Lets look at how we can interact with Google Analytics using &lt;a href="https://github.com/google/google-api-ruby-client"&gt;google-api-ruby-client&lt;/a&gt;.  At the end of this, we are going to be able to see the current traffic stats, top referrals, see a timeline of when the referals first came in, and do what we can from that information to track down who is talking about us.  GA will show us that we are getting a lot of &lt;code&gt;SOCIAL&lt;/code&gt; traffic, but what else can we figure out?&lt;/p&gt;

&lt;h2 id="step-1-setting-it-up-to-access-google-on-behalf-of-the-user"&gt;Step 1 Setting it up to access Google on behalf of the user&lt;/h2&gt;

&lt;p&gt;We&amp;#39;re going to be using OAuth2 to authorize our script.  So head over to the &lt;a href="https://console.developers.google.com/project"&gt;Google Developers Console&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Create a Project&lt;/em&gt;.  You should name this something that makes sense to you.  I called my &lt;em&gt;Social Investigator&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enable the &lt;em&gt;Analytics API&lt;/em&gt;.  This can be done on the side bar, under &lt;strong&gt;APIs and auth &amp;gt; Apis&lt;/strong&gt;.  Scroll down to find it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;APIs and auth &amp;gt; Consent Screen&lt;/strong&gt;.  Create something here, you&amp;#39;ll need to flesh this out later.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;APIs and auth &amp;gt; Create Client ID&lt;/strong&gt;.  Select &lt;strong&gt;Installed Application&lt;/strong&gt; with type &lt;em&gt;Other&lt;/em&gt;.  This will create the keys for you, and then you &lt;strong&gt;Download JSON&lt;/strong&gt; and save it in a file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id="step-2-getting-an-access-token-and-an-api-file-using-installedappflow"&gt;Step 2 Getting an access token and an API file using InstalledAppFlow&lt;/h2&gt;

&lt;p&gt;Working with the Google API is pretty confusing at first, since there&amp;#39;s multiple steps that need to happen before you can even figure out how to make a call.  Twitter&amp;#39;s API, which in every other way is a joke compared to Google&amp;#39;s way of doing things, has a &lt;a href="/scripting-twitter"&gt;handy way to get a single use access token&lt;/a&gt;.  With Google you need to do this yourself.  And once that&amp;#39;s done, you need to load the API meta data from the API API to be able to access it!&lt;/p&gt;

&lt;p&gt;We&amp;#39;re going to be using a few gems to put in your &lt;code&gt;Gemfile&lt;/code&gt; specifically:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;source &amp;#39;https://rubygems.org&amp;#39;

gem &amp;#39;google-api-client&amp;#39;
gem &amp;#39;thor&amp;#39;
gem &amp;#39;hirb&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can use the &lt;code&gt;Google::APIClient::InstalledAppFlow&lt;/code&gt; class to open up a web browser, have the user log in as needed to their Google Accounts, and grant access to the API.  The code below shows the basics of this.  We assume that the file you downloaded in step 1 is called &lt;code&gt;client_secrets.json&lt;/code&gt; and in the same directory, and we are writing out the granted credentials into the &lt;code&gt;analytics-oauth2.json&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;#!/usr/bin/env ruby -KU
#
# This code has been adapted from
# https://github.com/google/google-api-ruby-client-samples/tree/master/drive
#

require &amp;#39;thor&amp;#39;
require &amp;#39;hirb&amp;#39;
require &amp;#39;google/api_client&amp;#39;
require &amp;#39;google/api_client/client_secrets&amp;#39;
require &amp;#39;google/api_client/auth/file_storage&amp;#39;
require &amp;#39;google/api_client/auth/installed_app&amp;#39;
require &amp;#39;logger&amp;#39;
require &amp;#39;csv&amp;#39;

API_VERSION = &amp;#39;v3&amp;#39;
CACHED_API_FILE = &amp;quot;analytics-#{API_VERSION}.cache&amp;quot;
CREDENTIAL_STORE_FILE = &amp;quot;analytics-oauth2.json&amp;quot;
CLIENT_SECRETS_FILE = &amp;quot;client_secrets.json&amp;quot;

class AnalyticsClient
  def initialize( file_caches = nil )
    client
  end

  def client
    return @client if @client

    @client = Google::APIClient.new(:application_name =&amp;gt; &amp;#39;Analyics-CLI&amp;#39;,
        :application_version =&amp;gt; &amp;#39;1.0.0&amp;#39;)

    # FileStorage stores auth credentials in a file, so they survive multiple runs
    # of the application. This avoids prompting the user for authorization every
    # time the access token expires, by remembering the refresh token.
    # Note: FileStorage is not suitable for multi-user applications.
    file_storage = Google::APIClient::FileStorage.new(CREDENTIAL_STORE_FILE)
    if file_storage.authorization.nil?
      client_secrets = Google::APIClient::ClientSecrets.load(CLIENT_SECRETS_FILE)
      # The InstalledAppFlow is a helper class to handle the OAuth 2.0 installed
      # application flow, which ties in with FileStorage to store credentials
      # between runs.
      flow = Google::APIClient::InstalledAppFlow.new(
        :client_id =&amp;gt; client_secrets.client_id,
        :client_secret =&amp;gt; client_secrets.client_secret,
        :scope =&amp;gt; [&amp;#39;https://www.googleapis.com/auth/analytics&amp;#39;]
      )
      @client.authorization = flow.authorize(file_storage)
    else
      @client.authorization = file_storage.authorization
    end

    @client
  end
end

if __FILE__ == $0
  AnalyticsClient.new.client
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this the first time, you should be prompted to grant access to your application.  The second time it should run and exit cleanly -- it has access, but we haven&amp;#39;t asked to do anything yet.&lt;/p&gt;

&lt;h2 id="step-3-discover-the-api"&gt;Step 3 Discover the API&lt;/h2&gt;

&lt;p&gt;Google takes their software development seriously, and it shows.  Not only are there many different APIs available to use, but they all have different versions.  These endpoints are all different, and rather than have them all hard coded into the client access library, you use the &lt;em&gt;discover api&lt;/em&gt; to pull in metadata associated with it.  The following code will load up this data and cache it to the filesystem so the next access will be faster.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def api
    return @api if @api

    # Load cached discovered API, if it exists. This prevents retrieving the
    # discovery document on every run, saving a round-trip to API servers.
    if File.exists? CACHED_API_FILE
      File.open(CACHED_API_FILE) do |file|
        @api = Marshal.load(file)
      end
    else
      @api = client.discovered_api(&amp;#39;analytics&amp;#39;, API_VERSION)
      File.open(CACHED_API_FILE, &amp;#39;w&amp;#39;) do |file|
        Marshal.dump(@api, file)
      end
    end

    @api
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-4-finding-a-web-profile"&gt;Step 4 Finding a web profile&lt;/h2&gt;

&lt;p&gt;In order to pull data from an analytics account, you need to query the management API to get a list of profiles that you user has access to.  We&amp;#39;re going to collapse the differences between accounts and properties, and print them all out in a list directly.  The key variable we are looking for is going to be the profile &lt;em&gt;id&lt;/em&gt;.  This is different from the &lt;em&gt;web property id&lt;/em&gt;, which is what you use in Javascript to add the tracking code (.e.g &lt;code&gt;UA-56296045-1&lt;/code&gt;).  We&amp;#39;ll also show the &lt;em&gt;websiteUrl&lt;/em&gt; associated with the account since that&amp;#39;s what people really know.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def profiles
    client.execute(
      api_method: api.management.profiles.list,
      parameters: { accountId: &amp;quot;~all&amp;quot;, webPropertyId: &amp;quot;~all&amp;quot; } )
  end

  def print_profiles
    profiles.data.items.each do |profile|
      printf &amp;quot;%-15d %-15s %s\n&amp;quot;, profile.id, profile.webPropertyId, profile.websiteUrl
    end
  end
end

if __FILE__ == $0
  AnalyticsClient.new.print_profiles
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-5-querying-with-ga-get"&gt;Step 5 Querying with ga.get&lt;/h2&gt;

&lt;p&gt;The main end point we are looking at is &lt;code&gt;ga.get&lt;/code&gt;.  There&amp;#39;s an &lt;a href="https://ga-dev-tools.appspot.com/explorer/"&gt;interactive developer tool&lt;/a&gt; that will let you experiment with what is available and how it works.   If you load up that tool now, you&amp;#39;ll see what we&amp;#39;ve written code that will let us find the property id for our query, so we are now ready to start querying.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Query Explorer&lt;/em&gt; is really useful because of the dropdowns around &lt;em&gt;dimensions&lt;/em&gt; and &lt;em&gt;metrics&lt;/em&gt;.  When you hover over any of the fields, documentation comes up which will explain what each of the fields mean.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Dimensions&lt;/em&gt; are different ways of slicing up the data.  These include things like &lt;em&gt;page title&lt;/em&gt;, &lt;em&gt;referer&lt;/em&gt;, &lt;em&gt;adwords&lt;/em&gt;, and other ways of slicing up the people that came to your site.  &lt;em&gt;Metrics&lt;/em&gt; are the actual data for these buckets of users, and include things like &lt;em&gt;sessions&lt;/em&gt;, &lt;em&gt;user counts&lt;/em&gt;, &lt;em&gt;page views&lt;/em&gt; and &lt;em&gt;average session duration&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In order to make the query we first need to setup the query parameters.  We&amp;#39;ve split that off into its own method called &lt;code&gt;query_template&lt;/code&gt;.  The required fields are &lt;em&gt;profile id&lt;/em&gt;, &lt;em&gt;start date&lt;/em&gt;, and &lt;em&gt;end date&lt;/em&gt;.  We&amp;#39;re going to setup some defaults here which we will override in other methods when we use it.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def query_template( profile_id, start_date = nil, end_date = nil )
    today = Time.now.strftime( &amp;quot;%Y-%m-%d&amp;quot; )
    {
      &amp;quot;ids&amp;quot; =&amp;gt; &amp;quot;ga:#{profile_id}&amp;quot;,
      &amp;quot;start-date&amp;quot; =&amp;gt; start_date || today,
      &amp;quot;end-date&amp;quot; =&amp;gt; end_date || today,
      &amp;quot;sort&amp;quot; =&amp;gt; &amp;quot;-ga:pageviews&amp;quot;,
      &amp;quot;dimensions&amp;quot; =&amp;gt; &amp;quot;ga:pageTitle&amp;quot;,
      &amp;quot;metrics&amp;quot; =&amp;gt; &amp;quot;ga:pageviews,ga:newUsers,ga:users&amp;quot;
    }
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our default here is that we&amp;#39;re slicing on &lt;code&gt;pageTitle&lt;/code&gt;, showing &lt;code&gt;pageviews&lt;/code&gt;, &lt;code&gt;newUsers&lt;/code&gt;, and &lt;code&gt;users&lt;/code&gt; (which include returning users).&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s do an actual query with the parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def hotcontent( profile_id, start_date = nil, end_date = nil )
    query = query_template( profile_id, start_date, end_date )
    client.execute(
      api_method: api.data.ga.get,
      parameters: query
      )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need a way to print the result.  The result that we get back has two different things, &lt;code&gt;columnHeaders&lt;/code&gt; which is a reflection of the &lt;code&gt;query&lt;/code&gt; that we passed in, and the data itself is an array of arrays in &lt;code&gt;row&lt;/code&gt;.  We&amp;#39;re using &lt;code&gt;Hirb&lt;/code&gt; helper method here to format the result.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def print_query_result( r )
    headers = r.data.columnHeaders.collect { |x| x.name }
    puts Hirb::Helpers::AutoTable.render(r.data.rows, headers: headers )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s give it a try:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;if __FILE__ == $0
  client = AnalyticsClient.new
  results = client.hotcontent ARGV[0]
  client.print_query_result results
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you&amp;#39;ve made note of your profile id above, and we can see what it looks like now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ ruby ga.rb 93249816
+--------------------------------------------------+--------------+-------------+----------+
| ga:pageTitle                                     | ga:pageviews | ga:newUsers | ga:users |
+--------------------------------------------------+--------------+-------------+----------+
| Building Sites with Middleman | Will Schenk      | 26           | 11          | 24       |
| Bootstrap: Advanced Grid Tricks | Will Schenk    | 11           | 7           | 11       |
| Making a command line utility with gems and thor | 9            | 2           | 6        |
| Will Schenk | Will Schenk                        | 9            | 2           | 5        |
| Making Yosemite Faster | Will Schenk             | 8            | 7           | 8        |
| How to track your coworkers | Will Schenk        | 6            | 1           | 6        |
| Will Schenk - How to track your coworkers        | 3            | 0           | 1        |
+--------------------------------------------------+--------------+-------------+----------+
7 rows in set
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-6-adding-more-commands"&gt;Step 6 Adding more commands&lt;/h2&gt;

&lt;p&gt;Lets create a &lt;code&gt;Thor&lt;/code&gt; class here for the things that we want to query, and then go through a implement the calls in the &lt;code&gt;AnalyticsClient&lt;/code&gt; class.&lt;/p&gt;

&lt;p&gt;We want to be able to specify the timeframe for when we want the results.  It defaults to the current date, but lets add some more options for &lt;strong&gt;today&lt;/strong&gt;, &lt;strong&gt;yesterday&lt;/strong&gt;, &lt;strong&gt;recently&lt;/strong&gt; (last 7 days), and &lt;strong&gt;month&lt;/strong&gt; (last 30 days, which isn&amp;#39;t really a month but close enough.)&lt;/p&gt;

&lt;p&gt;We also want to have different output options, so we&amp;#39;ll add a &lt;strong&gt;table&lt;/strong&gt; switch, like the &lt;code&gt;Hirb&lt;/code&gt; output above, and &lt;strong&gt;csv&lt;/strong&gt; to make it easier to plug this into other tools.&lt;/p&gt;

&lt;p&gt;We&amp;#39;re going to create 4 different ways to query the data.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What content is getting traffic&lt;/li&gt;
&lt;li&gt;Who is linking to your site&lt;/li&gt;
&lt;li&gt;Who is linking to specific pages on your site&lt;/li&gt;
&lt;li&gt;A timeline of when content was published and people started linking to it&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Commands:
  ga.rb profiles                     # List Account Profiles
  ga.rb hotcontent PROFILE_ID        # Show hot content for profile id
  ga.rb referers PROFILE_ID          # Show hot content for profile id
  ga.rb content_referers PROFILE_ID  # Show hot content for profile id
  ga.rb timeline PROFILE_ID          # Show a timeline of referers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;#39;s the CLI code:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;class HammerOfTheGods &amp;lt; Thor
  desc &amp;quot;profiles&amp;quot;, &amp;quot;List Account Profiles&amp;quot;
  def profiles
    client.print_profiles
  end

  desc &amp;quot;hotcontent PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv]
  def hotcontent( profile_id )
    result = client.hotcontent( profile_id, start_date, end_date )
    print_result result
  end

  desc &amp;quot;referers PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv]
  def referers( profile_id )
    result = client.referers( profile_id, start_date, end_date )
    print_result( result )
  end

  desc &amp;quot;content_referers PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv]
  def content_referers( profile_id )
    result = client.content_referers( profile_id, start_date, end_date )
    print_result( result )
  end

  desc &amp;quot;timeline PROFILE_ID&amp;quot;, &amp;quot;Show a timeline of referers&amp;quot;
  def timeline( profile_id )
    client.timeline( profile_id )
  end

  private
  def client
    @client ||= AnalyticsClient.new
  end

  def start_date
    return (Time.now - (24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:yesterday]
    return (Time.now - (7*24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:recently]
    return (Time.now - (30*24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:month]
    nil
  end

  def end_date
    return (Time.now - (24*60*60)).strftime( &amp;quot;%Y-%m-%d&amp;quot; ) if options[:yesterday]
    nil
  end

  def print_result( result )
    if options[:csv]
      client.print_csv_result( result )
    else
      client.print_query_result( result )
    end
  end
end

if __FILE__ == $0
  HammerOfTheGods.start(ARGV)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-7-lets-implement"&gt;Step 7 Lets implement&lt;/h2&gt;

&lt;p&gt;We have the &lt;code&gt;profiles&lt;/code&gt; command and the &lt;code&gt;hotcontent&lt;/code&gt; command, or &lt;strong&gt;what content is getting traffic&lt;/strong&gt; working already.  Lets add some code to make the &lt;code&gt;--csv&lt;/code&gt; option work, this goes into the &lt;code&gt;AnalyticsClient&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def print_csv_result(r)
    csv_string = CSV.generate do |csv|
      csv &amp;lt;&amp;lt; r.data.columnHeaders.collect { |x| x.name }
      r.data.rows.each do |row|
        csv &amp;lt;&amp;lt; row
      end
    end

    puts csv_string
    csv_string
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Who is linking to your site&lt;/strong&gt;?
We can find out by looking at &lt;code&gt;ga:source&lt;/code&gt; which is basically the domain, &lt;code&gt;ga:referralPath&lt;/code&gt; which is the path part of the url if it&amp;#39;s a link referral, and &lt;code&gt;ga:medium&lt;/code&gt; which will tell you if it&amp;#39;s linking from a direct url, social media link, email link, or ad traffic.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def referers( profile_id, start_date = nil, end_date = nil )
    query = query_template( profile_id, start_date, end_date )
    query[&amp;quot;dimensions&amp;quot;] = &amp;quot;ga:source,ga:referralPath,ga:medium&amp;quot;
    client.execute(
      api_method: api.data.ga.get,
      parameters: query
      )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Who is linking to specific pages on your site&lt;/strong&gt; can be dertimined by adding the &lt;code&gt;ga:landingPagePath&lt;/code&gt; dimension to the above query.  This now breakdown the source of traffic not to the site as a whole, but to a specific landing page.  We&amp;#39;re also changing the &lt;code&gt;sort&lt;/code&gt; query parameter to take this additional dimension into effect.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def content_referers( profile_id, start_date = nil, end_date = nil )
    query = query_template( profile_id, start_date, end_date )
    query[&amp;quot;dimensions&amp;quot;] = &amp;quot;ga:landingPagePath,ga:source,ga:referralPath,ga:medium&amp;quot;
    query[&amp;quot;sort&amp;quot;] = &amp;quot;ga:landingPagePath,-ga:pageviews&amp;quot;

    client.execute(
      api_method: api.data.ga.get,
      parameters: query
      )
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works, but we can change the way it&amp;#39;s printed out to be visually more useful.  In the &lt;code&gt;HammerOfTheGods&lt;/code&gt; we can flesh it out a bit, so it only prints out your local path once while listing the referals indented so you can scan and see what&amp;#39;s going on grouped by page.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  desc &amp;quot;content_referers PROFILE_ID&amp;quot;, &amp;quot;Show hot content for profile id&amp;quot;
  options [:today, :yesterday, :recently, :month, :table, :csv, :full]
  def content_referers( profile_id )
    result = client.content_referers( profile_id, start_date, end_date )

    if options[:table] || options[:csv]
      print_result( result )
    else
      last_title = nil

      result.data.rows.each do |row|
        puts &amp;quot;\n#{row[0]}&amp;quot; if last_title != row[0]
        last_title = row[0]
        printf( &amp;quot;     %-5s %-8s %s%s\n&amp;quot;, row[4], row[3], row[1], row[2])
      end
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="step-8-the-timeline"&gt;Step 8 The timeline&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;A timeline of when content was published and people started linking to it&lt;/strong&gt; can be created by combinding 2 of the methods that we&amp;#39;ve already written, &lt;code&gt;hotcontent&lt;/code&gt; and &lt;code&gt;referers&lt;/code&gt;, and looping through and querying them one day at a time.&lt;/p&gt;

&lt;p&gt;We start 30 days ago, and get a list of content for that day.  If we haven&amp;#39;t seen it before, we say that it was posted that day.  We then get a list of referrals for that day.  If we haven&amp;#39;t seen them before, we print it out.  I&amp;#39;m also supressing links that have passed in less that 2 visitors, since they tend to be very noisey.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;  def timeline( profile_id )
    one_month_ago = Time.now - 30 * 24 * 60 * 60

    start_date = one_month_ago

    today = Time.now

    seen = {}
    title = {}
    while start_date.to_date &amp;lt;= today.to_date
      puts
      puts start_date.to_date

      contents = hotcontent( profile_id, start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ), start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ) )
      contents.data.rows.each do |content|
        unless title[content[0]]
          puts &amp;quot;  Posted:  #{content[0]}&amp;quot;
        end

        title[content[0]] = true
      end
      puts

      result = referers( profile_id, start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ), start_date.strftime( &amp;quot;%Y-%m-%d&amp;quot; ) )
      result.data.rows.each do |data|
        url = data[0]
        url = &amp;quot;http://#{data[0]}#{data[1]}&amp;quot; if data[2] == &amp;#39;referral&amp;#39;
        printf &amp;quot;  %-10s %5s %s\n&amp;quot;, data[2], data[3],url if !seen[url] &amp;amp;&amp;amp; data[3].to_i &amp;gt; 2
        seen[url] = true if data[2] == &amp;#39;referral&amp;#39;
      end
      start_date = start_date + 24 * 60 * 60
    end
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="code"&gt;Code&lt;/h2&gt;

&lt;p&gt;The &lt;a href="https://gist.github.com/wschenk/d7f8650d619d8f68730a"&gt;full code is available to play with&lt;/a&gt;.  The mechanism for talking to Google APIs from a script works everywhere, but if you are going to do this on your server you&amp;#39;ll want to get the OAuth2 key using a different process than the &lt;code&gt;InstalledAppFlow&lt;/code&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>New HappySeed released</title>
    <link rel="alternate" href="http://willschenk.com/new-happyseed-released/"/>
    <id>http://willschenk.com/new-happyseed-released/</id>
    <published>2014-11-28T14:05:00-05:00</published>
    <updated>2014-11-28T14:05:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;h2 id="make-apps-faster"&gt;Make apps faster&lt;/h2&gt;

&lt;p&gt;Head on over to the &lt;a href="http://seed.happyfuncorp.com"&gt;HappySeed website&lt;/a&gt; to get the latest version of HappyFunCorp&amp;#39;s starter application toolkit.&lt;/p&gt;

&lt;p&gt;HappySeed is a set of application templates to help you get started building out new sites. The main section is a rails application template plus a set of rails generators to help you get started with rails appliations quickly. These generators setup the configuration of the application in a standard way, and the full set of generators include many things for setting up a modern rails app and well as middleman apps.&lt;/p&gt;

&lt;p&gt;You can update your command line tools by doing&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gem install happy_seed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then create rails apps, plugins, engines, and middleman static sites using the new &lt;code&gt;happy_seed&lt;/code&gt; tool.&lt;/p&gt;

&lt;h2 id="rails-sites"&gt;Rails sites&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed rails app_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/rails.html"&gt;Read rails documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="rails-plugins"&gt;Rails Plugins&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed plugin plugin_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/plugin.html"&gt;Read plug-in documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="rails-engines"&gt;Rails Engines&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed engine engine_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/plugin.html"&gt;Read engine documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="middleman-static-sites"&gt;Middleman Static Sites&lt;/h2&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ happy_seed static static_site
[...]
$ happy_seed static_blog static_site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://seed.happyfuncorp.com/docs/middleman.html"&gt;Read static documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="get-that-code"&gt;Get that code&lt;/h2&gt;

&lt;p&gt;Head on over to &lt;a href="https://github.com/HappyFunCorp/happy_seed"&gt;github&lt;/a&gt; to check it out!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Image Credit: &lt;a href="http://consciouslifenews.com"&gt;consciouslife news&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Building Sites with Middleman</title>
    <link rel="alternate" href="http://willschenk.com/building-sites-with-middleman/"/>
    <id>http://willschenk.com/building-sites-with-middleman/</id>
    <published>2014-11-24T19:00:00-05:00</published>
    <updated>2014-11-24T19:00:00-05:00</updated>
    <author>
      <name>Will Schenk</name>
    </author>
    <content type="html">&lt;p&gt;I make a lot of websites, and I have a certain toolkit that I use to build them.  The most useful things I use are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;layouts and partials so I only need to set things up once&lt;/li&gt;
&lt;li&gt;&lt;code&gt;haml&lt;/code&gt; for writing html, since I don&amp;#39;t like closing tags&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt; and &lt;code&gt;sass&lt;/code&gt; for writing css&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Markdown&lt;/code&gt; for formatting large blogs of content&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coffeescript&lt;/code&gt; for JavaScript&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Middleman is a static site generator, which means that it takes a bunch of source files, does some stuff with it, and produces static HTML, CSS, Images, and Javascript that can be hosted on a basic server somewhere, including &lt;a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteHosting.html"&gt;hosting on S3&lt;/a&gt; or &lt;a href="https://pages.github.com"&gt;Github Pages&lt;/a&gt; so you don&amp;#39;t need to consider a server.&lt;/p&gt;

&lt;p&gt;Middleman is written in Ruby, so it&amp;#39;s our familiar toolset, and unlike &lt;a href="http://jekyllrb.com"&gt;Jekyll&lt;/a&gt; it uses &lt;a href="https://github.com/sstephenson/sprockets"&gt;Sprockets&lt;/a&gt;, which is the same asset pipelining system that Rails uses.  So you get all the benefits of using a robust system that works for Rails apps without having to learn a bunch more things.&lt;/p&gt;

&lt;p&gt;In the node world &lt;a href="http://yeoman.io"&gt;Yeoman&lt;/a&gt; does something similar, but I personally have had poor luck getting &lt;a href="http://gruntjs.com"&gt;Grunt&lt;/a&gt; to work reliably in practice.&lt;/p&gt;

&lt;h2 id="setting-up-a-simple-static-site-with-middleman"&gt;Setting up a simple static site with Middleman&lt;/h2&gt;

&lt;p&gt;One of the problems with starting with Middleman is that there are so many places to start.  Lets look at how to setup a basic middleman site with bootstrap-sass, haml, and bower.  First thing is to install middleman:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gem install middleman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And create an app:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ middleman new static_site
[...]
      create  static_site/.gitignore
      create  static_site/config.rb
      create  static_site/source/index.html.erb
      create  static_site/source/layouts/layout.erb
      create  static_site/source/stylesheets
      create  static_site/source/stylesheets/all.css
      create  static_site/source/stylesheets/normalize.css
      create  static_site/source/javascripts
      create  static_site/source/javascripts/all.js
      create  static_site/source/images
      create  static_site/source/images/background.png
      create  static_site/source/images/middleman.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates 4 files in the main directory, &lt;code&gt;Gemfile&lt;/code&gt; and &lt;code&gt;Gemfile.lock&lt;/code&gt;, which we know and love, &lt;code&gt;config.rb&lt;/code&gt; which configures how middleman generates the site, and &lt;code&gt;source&lt;/code&gt; which are the sourcefiles of the site.&lt;/p&gt;

&lt;h2 id="gemfile"&gt;Gemfile&lt;/h2&gt;

&lt;p&gt;By default, &lt;code&gt;middleman&lt;/code&gt; installs the &lt;code&gt;middleman-livereload&lt;/code&gt; plugin, so in development mode any browers that have a page open with refresh when you save a file.  This makes testing a lot easier.  We can install other gems here to add different functionality.  Let&amp;#39;s add a few of these now:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;gem &amp;quot;middleman-deploy&amp;quot;
gem &amp;#39;middleman-bootstrap-navbar&amp;#39;
gem &amp;quot;bootstrap-sass&amp;quot;
gem &amp;quot;jquery-middleman&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first two gems expand the functionality of middleman, one to add tasks to push the final site build to &lt;code&gt;s3&lt;/code&gt;, &lt;code&gt;gh-pages&lt;/code&gt; and a whole bunch more, and the second to make it easier to build &lt;code&gt;bootstrap&lt;/code&gt; navbars.&lt;/p&gt;

&lt;p&gt;The file two are including &lt;code&gt;bootstrap-sass&lt;/code&gt; -- the same that we use for rails sites -- and &lt;code&gt;jquery&lt;/code&gt;.  These get included into the sprockets asset path, so you don&amp;#39;t need to maintain them in your project.  (We&amp;#39;ll also see below how to integrate &lt;code&gt;bower&lt;/code&gt; components into your project.)&lt;/p&gt;

&lt;h2 id="tweaking-middleman"&gt;Tweaking Middleman&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;config.rb&lt;/code&gt; is where we configure how middleman itself works.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# For custom domains on github pages
page &amp;quot;CNAME&amp;quot;, layout: false

set :css_dir, &amp;#39;stylesheets&amp;#39;
set :js_dir, &amp;#39;javascripts&amp;#39;
set :images_dir, &amp;#39;images&amp;#39;

# Better markdown support
# set :markdown, :tables =&amp;gt; true, :autolink =&amp;gt; true, :gh_blockcode =&amp;gt; true, :fenced_code_blocks =&amp;gt; true
# set :markdown_engine, :redcarpet

# Turn this on if you want to make your url&amp;#39;s prettier, without the .html
activate :directory_indexes

# Automatic image dimensions on image_tag helper
# activate :automatic_image_sizes

# Easier bootstrap navbars
activate :bootstrap_navbar

configure :development do
  activate :livereload
end

# Build-specific configuration
configure :build do
  # Any files you want to ignore:
  ignore &amp;#39;/admin/*&amp;#39;

  # For example, change the Compass output style for deployment
  activate :minify_css

  # Minify Javascript on build
  activate :minify_javascript

  # Enable cache buster
  activate :asset_hash

  # Use relative URLs
  activate :relative_assets
end


# This will push to the gh-pages branch of the repo, which will
# host it on github pages (If this is a github repository)
activate :deploy do |deploy|
  deploy.method = :git
  deploy.build_before = true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets go through this in detail.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;page &amp;quot;CNAME&amp;quot;, layout: false&lt;/code&gt;  says to move the file called &lt;code&gt;CNAME&lt;/code&gt; over without wrapping in the main layout.  Since this file doesn&amp;#39;t have .html in the name, it would otherwise get ignored.  This file is for having a custom domain on Github Pages, if that&amp;#39;s the sort of thing you are in to.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;set&lt;/code&gt; commands are there to configure different middleman settings, here to show where the various stylesheet, image, and css directories are.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;activate :directory_indexes&lt;/code&gt; with enable &lt;em&gt;pretty urls&lt;/em&gt;.  Directory indexes means that files named &lt;code&gt;about.html&lt;/code&gt; will actually get generated into a file called &lt;code&gt;/about/index.html&lt;/code&gt;, and will rely on the underlying server to have &lt;code&gt;/about&lt;/code&gt; actually show the directory &amp;quot;index&amp;quot; page, making the urls prettier.  This doesn&amp;#39;t work on all servers but works on most of them.  This plugin will actually rewrite the output of the &lt;code&gt;link_to&lt;/code&gt; tags, so you don&amp;#39;t need to adjust your templates to work.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;activate :bootstrap_navbar&lt;/code&gt; is an extension that we added in the Gemfile, which makes it easier to generate bootstrap navbars.  Extensions generally work in three ways: they add helper methods, they change the way that the sitemap is processed, or they add different commands to the &amp;quot;middleman&amp;quot; command.&lt;/p&gt;

&lt;p&gt;We see an example of that at the bottom of the &lt;code&gt;config.rb&lt;/code&gt; file, where we configure the &lt;code&gt;deploy&lt;/code&gt; extension:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;activate :deploy do |deploy|
  deploy.method = :git
  deploy.build_before = true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also takes some configuration, and in this case it set to deploy to github pages, and to make sure that it generates the site before doing so.  Here is the &lt;a href="https://github.com/karlfreeman/middleman-deploy"&gt;middleman-deploy&lt;/a&gt; github page with documentation.&lt;/p&gt;

&lt;p&gt;There are two sections that each configure a different middleman environment.  The first is used when you run &lt;code&gt;middleman server&lt;/code&gt; to look at the site locally:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;configure :development do
  activate :livereload
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final section is configuring the &lt;code&gt;build&lt;/code&gt; process, when you run &lt;code&gt;middleman build&lt;/code&gt; and it creates the generated files in the &lt;code&gt;build&lt;/code&gt; directory.  The entry below ignores certain files for the build, and runs minifiers over the css and javascript, and turns on &lt;em&gt;cache busting&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Build-specific configuration
configure :build do
  # Any files you want to ignore:
  ignore &amp;#39;/admin/*&amp;#39;

  # For example, change the Compass output style for deployment
  activate :minify_css

  # Minify Javascript on build
  activate :minify_javascript

  # Enable cache buster
  activate :asset_hash

  # Use relative URLs
  activate :relative_assets
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="using-bower"&gt;Using bower&lt;/h2&gt;

&lt;p&gt;The basic way to use bower is to put this in &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;sprockets.append_path File.join root, &amp;#39;bower_components&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then you can put things in your &lt;code&gt;all.js&lt;/code&gt; file like&lt;/p&gt;

&lt;pre&gt;&lt;code class="javascript"&gt;//= require &amp;#39;component&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get all of the assets that are included in the packge, you may need to specify the package in the &lt;code&gt;config.rb&lt;/code&gt; file, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;sprockets.import_asset &amp;#39;jquery&amp;#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information on the &lt;a href="http://middlemanapp.com/basics/asset-pipeline/"&gt;Middleman Asset Pipline documentation&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="using-layouts-and-partials"&gt;Using layouts and partials&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;source&lt;/code&gt; directory is where the actual code for your site lives.  Here is an example &lt;code&gt;layouts/layout.haml&lt;/code&gt; file to give you a sense of how to use layouts and include partials:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;!!! 5
%html.no-js.sticky
  %head
    %meta{ :charset =&amp;gt; &amp;#39;utf-8&amp;#39; }/
    %meta{ &amp;#39;http-equiv&amp;#39; =&amp;gt; &amp;#39;X-UA-Compatible&amp;#39;, :content =&amp;gt; &amp;#39;IE=edge,chrome=1&amp;#39; }/

    %title This site is amazing!

    %meta{ :name =&amp;gt; &amp;#39;description&amp;#39;, :content =&amp;gt; &amp;#39;&amp;#39; }/
    %meta{ :name =&amp;gt; &amp;#39;viewport&amp;#39;, :content =&amp;gt; &amp;#39;width=device-width&amp;#39; }/
    = stylesheet_link_tag &amp;#39;application&amp;#39;, &amp;quot;socicons&amp;quot;, &amp;quot;animate&amp;quot;

  %body
    = partial &amp;quot;layouts/main_header&amp;quot;

    ~ yield

    = partial &amp;quot;layouts/footer&amp;quot;
    = partial &amp;quot;layouts/javascripts&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this usage, this is similar to the way that rails layouts work.  I&amp;#39;m using the &lt;code&gt;~&lt;/code&gt; HAML operator inside of &lt;code&gt;=&lt;/code&gt; here because I want to make sure that it doesn&amp;#39;t do anything wonky with the indention on &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; blocks, btw.&lt;/p&gt;

&lt;p&gt;Middleman has a concept of nested layouts, which lets you have wrap an a layout around another one.  I think that this is confusing in practice, but as an example you could have a &lt;code&gt;layouts/sidebar_layout.erb&lt;/code&gt; that looked like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="erb"&gt;&amp;lt;% wrap_layout :layout do %&amp;gt;
    &amp;lt;div class=&amp;quot;sidebar&amp;quot;&amp;gt;
        &amp;lt;%= partial &amp;quot;layouts/sidebar&amp;quot; %&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
        &amp;lt;%= yield %&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="the-yaml-preable-the-preyaml"&gt;The YAML preable the preyaml&lt;/h2&gt;

&lt;p&gt;Metadata about the template is included in a block of text at the top of the file, which gets pulled off to set things that the templating system can use later.  On the top of this file that I am editing right now, it looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;#39;Building Sites with Middleman&amp;#39;
subtitle: &amp;#39;lean publishing&amp;#39;
tags: middleman, ruby, howto
header_image: books.jpg
---

I make a lot of websites, and I have a certain toolkit that I use to build... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;subtitle&lt;/code&gt;, &lt;code&gt;tags&lt;/code&gt; and &lt;code&gt;header_image&lt;/code&gt; attributues are available in the templates as page data, so you can access them like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;  %h1= current_article.title
  %h2= current_article.data[&amp;#39;subtitle&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;title&lt;/em&gt; is built into middleman, &lt;em&gt;subtitle&lt;/em&gt; and &lt;em&gt;header image&lt;/em&gt; are just some random things I made up.  The &lt;code&gt;tags&lt;/code&gt; attribute is part of the &lt;code&gt;middleman-blog&lt;/code&gt; extension which we will cover below.&lt;/p&gt;

&lt;h2 id="how-the-build-works"&gt;How the build works&lt;/h2&gt;

&lt;p&gt;When you run &lt;code&gt;middleman server&lt;/code&gt; or &lt;code&gt;middleman build&lt;/code&gt;, middleman loads up the configuration file in &lt;code&gt;config.rb&lt;/code&gt;.  It creates a sitemap based upon the files in the &lt;code&gt;source&lt;/code&gt; directory as well as other directives inside of the config.rb file. &lt;/p&gt;

&lt;p&gt;By default it only includes files like &lt;code&gt;.html.erb&lt;/code&gt; and &lt;code&gt;.js&lt;/code&gt;, but you can set it manually include a non-template file (like our &lt;code&gt;page &amp;quot;CNAME&amp;quot;&lt;/code&gt; above or create other &lt;code&gt;proxy&lt;/code&gt; files.  Proxy files are a way of seperating out the templates from the source data.&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;# Assumes the file source/about/template.html.erb exists
[&amp;quot;tom&amp;quot;, &amp;quot;dick&amp;quot;, &amp;quot;harry&amp;quot;].each do |name|
  proxy &amp;quot;/about/#{name}.html&amp;quot;, &amp;quot;/about/template.html&amp;quot;, :locals =&amp;gt; { :person_name =&amp;gt; name }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates three entries into the sitemap called &lt;code&gt;/about/tom.html&lt;/code&gt;, &lt;code&gt;/about/dick.html&lt;/code&gt; and &lt;code&gt;/about/harry.html&lt;/code&gt; that use a specific template.&lt;/p&gt;

&lt;p&gt;This data doesn&amp;#39;t need to be hardcoded into the &lt;code&gt;config.rb&lt;/code&gt; btw, you can also place &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;yml&lt;/code&gt; files in the &lt;code&gt;data/&lt;/code&gt; directory which middleman will load automatically.  For example, &lt;code&gt;data/employees.json&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class="json"&gt;[{&amp;quot;name&amp;quot;:&amp;quot;Tom&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;Janitor&amp;quot;},{&amp;quot;name&amp;quot;:&amp;quot;Mary&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;CEO&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then in your &lt;code&gt;config.rb&lt;/code&gt; you could access this as:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;data[&amp;#39;employees&amp;#39;].each do |employee|
  proxy &amp;quot;/about/#{name}.html&amp;quot;, &amp;quot;/about/template.html&amp;quot;, :locals =&amp;gt; { :person_name =&amp;gt; employee[:name], :title =&amp;gt; employee[:title] }
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then each entry in the sitemap the file is processed (based upon the extension, so scss -&amp;gt; js, haml -&amp;gt; html, etc.) into the build directory.  Helper methods are available inside of the templates for things like &lt;code&gt;javascript_include_tag&lt;/code&gt;, &lt;code&gt;stylesheet_link_tag&lt;/code&gt;, &lt;code&gt;link_to&lt;/code&gt; and &lt;code&gt;image_tag&lt;/code&gt; and all of the rest.&lt;/p&gt;

&lt;h2 id="middleman-server"&gt;middleman server&lt;/h2&gt;

&lt;p&gt;Starting the server in preview mode will start a local server on port &lt;code&gt;4567&lt;/code&gt; that generates the files on demand.  If you have livereload enabled this will automatically trigger a page refresh for any open browsers, so you can tweak and look at things as you go.&lt;/p&gt;

&lt;p&gt;Inside of your templates, &lt;code&gt;config.environment == :development&lt;/code&gt; when you are in preview mode.  So, if there are some things that you don&amp;#39;t want to push to the live site but are useful for development, you can switch them on and off using that mechanism.&lt;/p&gt;

&lt;h2 id="middleman-build"&gt;middleman build&lt;/h2&gt;

&lt;p&gt;This does basically the same thing as the server, but the templates are generally further processed.  Cachebusting can be enabled, and you can include tracking code if &lt;code&gt;config.environment == :build&lt;/code&gt; is true.  This goes through all of the files in source that look like webfiles and places them in the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;And easy way to check out what you have there is by &lt;code&gt;cd&lt;/code&gt;ing into the &lt;code&gt;build/&lt;/code&gt; directory and running a simple webserver to serve the pages.  Relative links don&amp;#39;t work when you open the file directly in the browser, so you need to use an actual webserver.&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ cd build
$ python -m SimpleHTTPServer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then open a new browser on port &lt;code&gt;8000&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="middleman-deploy"&gt;middleman deploy&lt;/h2&gt;

&lt;p&gt;In the basic &lt;code&gt;:git&lt;/code&gt; setting that we have above, middleman deploy will build the site into the &lt;code&gt;build/&lt;/code&gt; directory, switch that directory to the &lt;code&gt;gh-pages&lt;/code&gt; branch, and push it to &lt;code&gt;origin&lt;/code&gt;.  Assuming that you are hosting your repo on github, this will publish the static content on github pages.&lt;/p&gt;

&lt;p&gt;If you want to use a &lt;a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/"&gt;custom domain&lt;/a&gt; then you need to create a &lt;code&gt;CNAME&lt;/code&gt; file in &lt;code&gt;source/&lt;/code&gt; with the domain name, and set up your DNS records to match.&lt;/p&gt;

&lt;p&gt;One thing to note is that while changes to the pages seem to deploy quickly, it takes a long time for the first push to github pages to show up, on the order of 10-15 minutes.&lt;/p&gt;

&lt;p&gt;More information on &lt;a href="https://github.com/karlfreeman/middleman-deploy"&gt;middleman-deploy&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="building-a-blog"&gt;Building a blog&lt;/h2&gt;

&lt;p&gt;There are two good extensions for building a blog with middleman.  The default template for blog is sort of confusing in the way that it&amp;#39;s laid out, mainly because it gets rid of the &lt;code&gt;layouts/&lt;/code&gt; directory, but let&amp;#39;s go through it and see how it&amp;#39;s supposed to work:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ gem install middleman-blog
$ middleman new static_blog --template=blog
      create  static_blog/.gitignore
      create  static_blog/config.rb
      create  static_blog/source
      create  static_blog/source/2012-01-01-example-article.html.markdown
      create  static_blog/source/calendar.html.erb
      create  static_blog/source/feed.xml.builder
      create  static_blog/source/index.html.erb
      create  static_blog/source/layout.erb
      create  static_blog/source/tag.html.erb
      create  static_blog/source/stylesheets
      create  static_blog/source/javascripts
      create  static_blog/source/images
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have another middleman site, with a bunch of files.  It also creates a new command:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ middleman article &amp;quot;This is the title of my article&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#39;s also include the &lt;code&gt;middleman-blog-drafts&lt;/code&gt; gem into the &lt;code&gt;Gemfile&lt;/code&gt;, &lt;code&gt;activate :drafts&lt;/code&gt; in `config.rb, and that will give us a few more commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class="sh"&gt;$ middleman draft &amp;quot;This is amazing&amp;quot;
      create  source/drafts/this-is-amazing.html.markdown
$ middleman publish source/drafts/this-is-amazing.html.markdown
      create  source/2014-11-25-this-is-amazing.html.markdown
      remove  source/drafts/this-is-amazing.html.markdown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This lets us keep drafts in git and doesn&amp;#39;t force us to commit to a date until we are ready to publish it.  There are &lt;code&gt;published&lt;/code&gt; and &lt;code&gt;date&lt;/code&gt; attributes that the default blog extension knows about to turn it on and off, and is a good example of something that you can see in development but not production, but that still leaves to moving files around manually to adjust the date.&lt;/p&gt;

&lt;h2 id="what-does-it-add"&gt;What does it add&lt;/h2&gt;

&lt;p&gt;In addition to the sitemap, we now have a &lt;code&gt;blog&lt;/code&gt;, &lt;code&gt;article&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt; concept inside of the middleman app.  Articles are represented as pages (by default using &lt;code&gt;markdown&lt;/code&gt;) but the &lt;code&gt;tag&lt;/code&gt; and &lt;code&gt;calendar&lt;/code&gt; templates are actually more like &lt;code&gt;proxy&lt;/code&gt; templates than file templates, and when the site is generated middleman will iterate over then to produce many output files from one template.&lt;/p&gt;

&lt;p&gt;Part of the &lt;code&gt;index.html.haml&lt;/code&gt; of this site looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class="haml"&gt;  - (drafts + page_articles).each do |article|
    .post
      .post-date
        - unless article.is_a? ::Middleman::Blog::Drafts::DraftArticle
          %p= article.date.strftime( &amp;#39;%b %e&amp;#39; )
        - else
          %p.draft Draft
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;#39;m putting all of the articles in a list, both drafts and published ones, and only showing the date for articles which have already been published.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s what gets added to the &lt;code&gt;config.rb&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class="rb"&gt;activate :blog do |blog|
  # This will add a prefix to all links, template references and source paths
  # blog.prefix = &amp;quot;blog&amp;quot;

  # blog.permalink = &amp;quot;{year}/{month}/{day}/{title}.html&amp;quot;
  # Matcher for blog source files
  # blog.sources = &amp;quot;{year}-{month}-{day}-{title}.html&amp;quot;
  # blog.taglink = &amp;quot;tags/{tag}.html&amp;quot;
  # blog.layout = &amp;quot;layout&amp;quot;
  # blog.summary_separator = /()/
  # blog.summary_length = 250
  # blog.year_link = &amp;quot;{year}.html&amp;quot;
  # blog.month_link = &amp;quot;{year}/{month}.html&amp;quot;
  # blog.day_link = &amp;quot;{year}/{month}/{day}.html&amp;quot;
  # blog.default_extension = &amp;quot;.markdown&amp;quot;

  blog.tag_template = &amp;quot;tag.html&amp;quot;
  blog.calendar_template = &amp;quot;calendar.html&amp;quot;

  # Enable pagination
  # blog.paginate = true
  # blog.per_page = 10
  # blog.page_link = &amp;quot;page/{num}&amp;quot;
end

activate :drafts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should be enough to get you started, and more &lt;a href="http://middlemanapp.com/basics/blogging/"&gt;documentation is here&lt;/a&gt; .  At this point it really becomes a design and development challenge, not figuring out how to use the tool.&lt;/p&gt;

&lt;h2 id="go-get-started"&gt;Go get started&lt;/h2&gt;

&lt;p&gt;Middleman gives you all of the front-end developer benefits of using a system like Rails, but outputs static content than can be served anywhere without any dependancies.  Many sites don&amp;#39;t really require all that for them to run, and it&amp;#39;s crazy to me that something as read heavy as a blog often can&amp;#39;t perform well under load given that it&amp;#39;s just serving up the same old stuff over and over again.  You want to have some tooling to make it easier, but it doesn&amp;#39;t need to be &lt;em&gt;run time&lt;/em&gt; tooling.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Image Credit: &lt;a href="https://www.flickr.com/photos/aigle_dore/6365101775/in/photolist-aGsP14-7PozJp-84P71r-dphot9-5qz3ks-eqHuv-6NP8d6-HdurS-aibaen-ix8Rbz-6buevW-7acJMF-8DFBf3-MLnGM-dGa2xi-f4HeM7-zXqL6-88og6h-r7w3U-2qKgwi-mcp7h-4eXcGM-9uv3gC-7BAEiV-5RzRtp-7JKRHh-6iUdMZ-2bUDT-8s4PDi-8pvSWc-dynb6k-zV2x5-4xWMzG-dsxGqc-7Cby3b-9t3zWm-b4jsc2-8YyqSQ-9ggca5-aGsPSg-68SVDi-4PNHrt-7JGpz4-aL22G2-q1ic-sZMVW-84NAEC-8JBSSW-9k6cM-89NBaJ"&gt;Moyan Brenn&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>
</feed>
